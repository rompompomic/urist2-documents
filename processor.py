"""Core document processing logic reused by CLI and web service."""

from __future__ import annotations

import base64
import json
import os
import re
import tempfile
import time
import zipfile
from dataclasses import dataclass
from datetime import date, datetime
from decimal import Decimal, InvalidOperation
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional
from zoneinfo import ZoneInfo

from openai import OpenAI
import pypdfium2 as pdfium
from PIL import Image
from dotenv import load_dotenv
from docxtpl import DocxTemplate, RichText  # Для динамических таблиц

# Load environment variables from .env file
load_dotenv()

# === Processing settings ===
GPT_MODEL = "gpt-5-mini"  # Using GPT-5-mini with vision capabilities
TEMPLATE_DOCX = Path("templ") / "Заявление на банкротство.docx"
FILLED_TEMPLATE_SUFFIX = " (заполненное)"
OUTPUT_DIR = Path("resultdoc")  # Папка для всех готовых документов

# Initialize OpenAI client
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

print(f"OK - Using {GPT_MODEL} for document processing")


@dataclass
class DocumentOutput:
    file: str
    document_type: str
    pages: int
    processing_time_seconds: float
    data: Dict[str, Any]
    error: Optional[str] = None
    extracted_text: Optional[str] = None


class DocumentProcessor:
    """Processes PDF documents and aggregates structured data."""

    def __init__(self) -> None:
        pass

    # Registries populated at startup by app.py or scheduler
    BANK_REGISTRY: Dict[str, Any] = {}
    MFO_REGISTRY: Dict[str, Any] = {}

    @classmethod
    def initialize_bank_registry(cls) -> None:
        """Load bank and MFO registries from disk into class attributes.

        This method is called from `app.py` at startup. It is safe to call
        multiple times; missing files will result in empty registries.
        """
        bank_file = Path("cbr_data") / "bank_registry.json"
        mfo_file = Path("cbr_data") / "mfo_registry.json"

        if bank_file.exists():
            try:
                with open(bank_file, "r", encoding="utf-8") as f:
                    cls.BANK_REGISTRY = json.load(f)
            except Exception as e:
                print(f"[WARN] Failed to load bank registry: {e}")
                cls.BANK_REGISTRY = {}
        else:
            cls.BANK_REGISTRY = {}

        if mfo_file.exists():
            try:
                with open(mfo_file, "r", encoding="utf-8") as f:
                    cls.MFO_REGISTRY = json.load(f)
            except Exception as e:
                print(f"[WARN] Failed to load MFO registry: {e}")
                cls.MFO_REGISTRY = {}
        else:
            cls.MFO_REGISTRY = {}

        print(f"Initialized BANK_REGISTRY: {len(cls.BANK_REGISTRY)} banks, MFO_REGISTRY: {len(cls.MFO_REGISTRY)} MFOs")

    # === Prompt configuration ===
    DOCUMENT_TYPES: Dict[str, Dict[str, Any]] = {
        "паспорт": {
            "keywords": ["паспорт", "passport", "гражданина рф", "гражданин российской федерации", "удостоверяющий личность"],
            "prompt": """Ты обрабатываешь внутренний паспорт гражданина РФ (книжечный образца 1997/2011). Даже если OCR даёт шум вроде повторяющихся строк "подписан на задачу" или пустые страницы, считай это водяными знаками и извлекай нужные поля по макету. Если реквизит нечитаем или отсутствует — ставь null, ничего не выдумывай и не проси дополнительных данных.

ВАЖНО: Выбирай только АКТУАЛЬНУЮ информацию!
- Если видишь несколько записей о регистрации (прописке) — выбери ПОСЛЕДНЮЮ (самую свежую по дате).
- Если есть несколько штампов о браке/разводе — укажи ПОСЛЕДНИЙ статус (актуальное семейное положение).
- Если есть отметка о снятии с регистрации и новая регистрация — бери только действующую прописку.

РАБОТА С РАЗМЫТЫМИ ШТАМПАМИ РЕГИСТРАЦИИ:
- Штамп о регистрации часто размыт или частично нечитаем — это нормально!
- СТАРАЙСЯ разобрать хотя бы: город, улицу, номер дома, номер квартиры
- Ищи ключевые слова в штампе: "ЗАРЕГИСТРИРОВАН", "ЧЕЛЯБИНСК", "УЛ.", "Д.", "КВ."
- Числа (номера домов, квартир) обычно читаются лучше букв
- Дата в штампе обычно внизу, формат ДД.ММ.ГГГГ (например: 29.02.2000)
- Даже если уверен только в части адреса (город + дом) — запиши то, что видишь
- НЕ оставляй поле "Прописка" пустым (null) если хотя бы часть адреса читается!

ФОРМАТИРОВАНИЕ ТЕКСТА:
- Если текст написан ЗАГЛАВНЫМИ БУКВАМИ (CAPS LOCK) — приведи к нормальному виду: "Иванов Иван Иванович", а не "ИВАНОВ ИВАН ИВАНОВИЧ".
- ФИО, адреса, названия организаций — с заглавной буквы, остальное строчными.
- Исключения: аббревиатуры (МВД, ЗАГС, УФМС) оставляй заглавными.
- Убирай лишние пробелы и приводи текст к читаемому виду.

Следуй шагам:
1. Разворот с фото (стр. 2-3):
        - Красный номер справа вверху: 4 цифры серии + 6 цифр номера.
        - Под заголовками "Фамилия", "Имя", "Отчество" — ФИО.
        - Строка "Пол" содержит "Муж" или "Жен".
        - Строка "Дата рождения" — приведи к формату ДД.ММ.ГГГГ даже если написано прописью.
        - КРИТИЧЕСКИ ВАЖНО: Строка "Место рождения" находится СРАЗУ ПОД датой рождения НА СТРАНИЦЕ 2-3:
          * ЭТО НЕ АДРЕС ПРОПИСКИ! Это место, где человек родился (часто другой город/область)
          * Форматируй через ЗАПЯТУЮ с сокращениями: "г." (город), "с." (село), "д." (деревня), "р-н" (район), "обл." (область), "край"
          * Порядок: населенный пункт, район, область/край
          * Примеры: "г. Москва", "с. Агинское, Саянский р-н, Красноярский край", "д. Петрово, Рязанская обл."
          * НЕ ПУТАЙ с адресом регистрации (прописки) со страницы 5-6!
2. Страница с данными о выдаче (стр. 2):
        - Блок "Выдан"/"Кем выдан" — название подразделения МВД.
        - Под ним дата выдачи цифрами.
        - Слева внизу код подразделения формата XXX-XXX.
3. Разворот регистрации (стр. 5-6):
        - ВНИМАНИЕ: Это АДРЕС РЕГИСТРАЦИИ (ПРОПИСКА) - НЕ ПУТАЙ с местом рождения со страницы 2-3!
        - МЕСТО РОЖДЕНИЯ (стр. 2-3) ≠ АДРЕС РЕГИСТРАЦИИ (стр. 5-6) - это РАЗНЫЕ вещи!
        - Если несколько записей о регистрации — выбери ПОСЛЕДНЮЮ (с самой поздней датой).
        - Игнорируй отметки "Снят с регистрации" — они указывают на старые адреса.
        - КРИТИЧЕСКИ ВАЖНО: Адрес регистрации может быть в ШТАМПЕ или рукописной записи:
          * Штамп содержит: "ЗАРЕГИСТРИРОВАН", дату внизу, адрес в центре (часто размыт, но читается)
          * Штамп выглядит как прямоугольная рамка с текстом внутри
          * Адрес в штампе может быть написан CAPS LOCK — приведи к нормальному виду
          * ОБЯЗАТЕЛЬНО ИЗВЛЕКИ ПОЛНЫЙ АДРЕС с указанием области/края/республики!
          * Формат адреса: ОБЛАСТЬ/КРАЙ, город, улица, дом, корпус (если есть), квартира
          * Примеры правильного формата:
            - "Челябинская область, г. Челябинск, ул. Ленина, д. 10, кв. 5"
            - "Краснодарский край, г. Краснодар, ул. Мира, д. 25А, корп. 2, кв. 100"
            - "г. Москва, ул. Тверская, д. 1, кв. 10"
          * Даже если текст размыт — попытайся разобрать числа (номера домов, квартир)
          * В старых штампах часто есть "ЧЕЛЯБИНСКАЯ ОБЛАСТЬ", "Г. ЧЕЛЯБИНСК", "УЛ. КРАСНОМОЛОТОВА" и т.д.
          * ОБЯЗАТЕЛЬНО включи название области/края в начало адреса (если это не федеральный город)!
          * ПРОВЕРЬ: адрес регистрации ВСЕГДА содержит улицу, дом, квартиру (чего нет в месте рождения)
        - Дата регистрации обычно ВНИЗУ штампа цифрами (ДД.ММ.ГГГГ)
        - Рядом может быть подпись должностного лица и печать.
4. Штампы о семейном положении (стр. 7-8):
        - ВНИМАНИЕ: Если несколько штампов — выбери ПОСЛЕДНИЙ (актуальный статус).
        - Если был брак, затем развод — статус "Разведен/Разведена".
        - Если есть запись о браке/разводе — статус, дата, орган.
        - Если штампов нет — статус "Не женат"/"Не замужем".
5. Печати о детях (стр. 9-20):
        - Каждая печать "Сведения о детях" — ФИО и дата рождения ребёнка.
        - Собери ВСЕ записи о детях (здесь актуальны все).

Если OCR пустой, ориентируйся на макет: ФИО в верхнем левом блоке, красный номер справа, штамп регистрации под надписью "зарегистрирован".

Верни JSON строго в формате:
{
  "ФИО": "...",
  "Фамилия_инициалы": "Иванов И.И.", #Тут ты сам пишешь на основе ФИО из паспорта
  "Фамилия_инициалы_рп": "Иванова И.И.", #Тут ты сам пишешь на основе ФИО из паспорта, но уже в родительном падеже
  "Пол": "мужской/женский",
  "Дата_рождения": "ДД.ММ.ГГГГ",
  "Место_рождения": "с. Агинское, Саянский р-н, Красноярский край",  # СТР. 2-3! Где РОДИЛСЯ человек. Формат: населенный пункт, район, область/край. БЕЗ улицы и дома!
  "Серия": "ХХХХ",
  "Номер": "XXXXXX",
  "Кем_выдан": "...",
  "Дата_выдачи": "ДД.ММ.ГГГГ",
  "Код_подразделения": "ХХХ-ХХХ",
  "Прописка": "Челябинская область, г. Челябинск, ул. Ленина, д. 10, кв. 5",  # СТР. 5-6! Где ПРОПИСАН человек. ОБЯЗАТЕЛЬНО: область/край, город, УЛИЦА, ДОМ, квартира
  "Дата_прописки": "ДД.ММ.ГГГГ",
  "Семейное_положение": "Женат/Замужем/Не женат/Не замужем/Разведен/Разведена",
  "Дети": [{"ФИО": "...", "Дата_рождения": "ДД.ММ.ГГГГ"}]
}
КРИТИЧЕСКИ ВАЖНО - НЕ ПУТАЙ ЭТИ ПОЛЯ:
- "Место_рождения" (стр. 2-3): Где человек РОДИЛСЯ. Без улицы/дома. Пример: "г. Москва" или "с. Агинское, Саянский р-н, Красноярский край"
- "Прописка" (стр. 5-6): Где человек ПРОПИСАН. ВСЕГДА с улицей и домом. Пример: "Челябинская область, г. Челябинск, ул. Ленина, д. 10, кв. 5"
- Если в одном поле видишь улицу и дом - это ПРОПИСКА, а не место рождения!

Дополнительно: 
- Поле "Место_рождения" ОБЯЗАТЕЛЬНО должно быть заполнено в формате: "тип населенного пункта (с сокращением), название, район, область/край". Примеры: "с. Агинское, Саянский р-н, Красноярский край", "г. Москва", "д. Петрово, Рязанская обл.". Если текст нечитабелен — напиши что видишь, но НЕ оставляй null!
- Поле "Прописка" ОБЯЗАТЕЛЬНО должно содержать ПОЛНЫЙ адрес с указанием области/края/республики! Примеры: "Челябинская область, г. Челябинск, ул. Ленина, д. 10, кв. 5", "Краснодарский край, г. Краснодар, ул. Мира, д. 25", "г. Москва, ул. Тверская, д. 1". НЕ пропускай название области/края в начале адреса!
Отсутствующие реквизиты ставь null. Ответ должен содержать только чистый JSON без Markdown и пояснений. Если красный номер или текст не читабелен — ключи всё равно присутствуют, значение = null. Никогда не отвечай текстом вне JSON и не задавай вопросов пользователю.""",
        },
        "инн": {
            "keywords": ["инн", "налогоплательщика", "кнд 1122003", "копия инн", "индивидуальный номер налогоплательщика", "фнс", "налоговая служба", "свидетельство инн"],
            "prompt": """Ты обрабатываешь свидетельство или выписку ФНС об ИНН физического лица (форма КНД 1122003 или свидетельство на бумаге).

ВНИМАНИЕ: Это НЕ ЕГРН! Если видишь "Единого государственного реестра недвижимости" или "кадастровый номер" — это не ИНН документ.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО с заглавной буквы, остальное строчными).

ГДЕ ИСКАТЬ ИНН:
1. Старое свидетельство (бумажное):
   - В центре документа крупными цифрами: 12 цифр ИНН
   - Выше или ниже указано ФИО
   - Может быть печать налоговой инспекции

2. Новая выписка (форма КНД 1122003):
   - Шапка: логотип ФНС, название "Сведения об ИНН"
   - Таблица с полями: ФИО, ИНН (12 цифр), дата рождения
   - Правый угол: дата формирования

3. Простая справка/копия:
   - Может быть просто текст с ИНН и ФИО
   - ИНН — это ВСЕГДА 12 цифр (для физических лиц)

КРИТИЧЕСКИ ВАЖНО - ФОРМАТЫ ИНН:
ИНН физического лица может быть записан по-разному:
- Слитно: 745210776146
- С пробелами: 745 210 776 146
- С дефисами: 745-210-776-146
- Группами: 7452 1077 6146
- Частично размыт: некоторые цифры нечитаемы

ИНСТРУКЦИЯ:
- ИНН физлица ВСЕГДА 12 цифр (для юрлиц 10 цифр - это не наш случай!)
- Если видишь группу из ~12 цифр рядом со словом "ИНН" - это он!
- Убери все пробелы, дефисы, точки - оставь только 12 цифр
- Если часть цифр размыта но видно 10-11 цифр - попытайся разобрать остальные
- Ищи ИНН: в центре документа крупными цифрами, в таблице напротив "ИНН", в шапке
- НЕ путай с ОГРН (13-15 цифр), СНИЛС (11 цифр), датами, номерами документов

Верни JSON:
{
  "ФИО": "...",
  "ИНН": "XXXXXXXXXXXX",
  "Дата_рождения": "ДД.ММ.ГГГГ",
  "Дата_формирования": "ДД.ММ.ГГГГ",
  "Вид_документа": "Свидетельство ИНН / Выписка ФНС"
}

ВАЖНО: Если не нашел 12-значный номер ИНН, но видишь ФИО — всё равно верни JSON с ИНН=null.
Никаких комментариев и пояснений!"""
        },
        "снилс": {
            "keywords": ["снилс", "страховое свидетельство", "страховой номер", "зелёная", "сфр", "страховой номер индивидуального лицевого счета", "пфр", "пенсионный фонд", "индивидуального лицевого счета"],
            "prompt": """Ты обрабатываешь страховое свидетельство обязательного пенсионного страхования (СНИЛС) — старый зелёный пластик или новая электронная справка.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО, адреса с заглавной буквы).

КРИТИЧЕСКИ ВАЖНО - ФОРМАТЫ СНИЛС:
СНИЛС может быть записан по-разному:
- Правильно: 123-456-789 12
- Слитно: 12345678912
- С пробелами: 123 456 789 12
- Без дефисов: 123 456 789 12
- С точками: 123.456.789.12
- Частично размыт

ИНСТРУКЦИЯ:
- СНИЛС ВСЕГДА 11 цифр в стандартном формате XXX-XXX-XXX XX
- Ищи ~11 цифр рядом со словами: "СНИЛС", "Страховой номер", "СФР"
- Убери все пробелы, дефисы, точки
- Приведи к правильному формату: XXX-XXX-XXX XX (с дефисами между тройками и пробелом перед последней двойкой)
- Если часть цифр размыта - попытайся разобрать хотя бы 9-10 цифр
- НЕ путай с ИНН (12 цифр), телефоном, другими номерами

1. Старый бланк:
        - Заголовок "Страховое свидетельство" и строка "Страховой номер" — формат XXX-XXX-XXX XX.
        - Ниже блок "Фамилия", "Имя", "Отчество".
        - Внизу слева "Дата рождения" и "Место рождения".
        - Под подписью страхователя — дата выдачи.
2. Новая справка СФР:
        - Шапка "Страховой номер индивидуального лицевого счёта" — рядом СНИЛС.
        - Таблица с ФИО, датой и местом рождения.

Если OCR пустой, используй макет: номер крупно в центре, ФИО блоком ниже, дата рождения под ФИО.

Верни JSON:
{
  "ФИО": "...",
  "СНИЛС": "XXX-XXX-XXX XX",
  "Дата_рождения": "ДД.ММ.ГГГГ",
  "Место_рождения": "...",
  "Дата_выдачи": "ДД.ММ.ГГГГ",
  "Тип_бланка": "карта 1997/справка СФР"
}
Если реквизит не найден, ставь null. Никаких дополнительных комментариев.""",
        },
        "сзиилс": {
            "keywords": ["сзи-илс", "индивидуального лицевого", "ипк", "состоянии индивидуального", "сзиилс", "сведения о застрахованном лице", "индивидуальный лицевой счет", "пенсионные баллы", "стаж", "сфр", "пфр"],
            "prompt": """Документ "Сведения о состоянии индивидуального лицевого счёта" (форма СЗИ-ИЛС).

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (названия организаций с заглавной).

Найди в шапке: ФИО, СНИЛС, дату рождения, дату формирования ("дата приёма" или "сформировано").
Строка "Величина индивидуального пенсионного коэффициента" — число с точкой.
Внизу раздела указан расчётный пенсионный капитал (рубли и копейки).
Таблица 1 перечисляет периоды с 2015 года: период, работодатель, суммы выплат, взносов, величину ИПК, длительность.
Если есть разделы о периодах до 2015 года — перечисли их отдельным списком.
При слабом OCR ориентируйся на колонки "Период", "Работодатель", "Сумма выплат".

JSON:
{
        "ФИО": "...",
        "СНИЛС": "...",
        "Дата_рождения": "ДД.ММ.ГГГГ",
        "Дата_формирования": "ДД.ММ.ГГГГ",
        "ИПК": "...",
        "Пенсионный_капитал": "...",
        "Периоды": [
                {
                        "Период": "01.01.2019-31.12.2019",
                        "Работодатель": "...",
                        "Сумма_выплат": "...",
                        "Сумма_взносов": "...",
                        "ИПК": "...",
                        "Длительность": "..."
                }
        ],
        "Периоды_до_2015": ["..."]
}
Пустые поля = null, списки допускают [] и null, но ключи обязательны. Без комментариев.""",
        },
        "налоговое_уведомление": {
            "keywords": ["налоговое уведомление", "транспортный налог", "налог на имущество физических лиц", "всего к уплате"],
            "prompt": """Налоговое уведомление ФНС о необходимости уплаты налогов.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Найди в документе:
- Номер и дату уведомления (в шапке)
- ФИО налогоплательщика
- ИНН налогоплательщика
- Срок уплаты
- ВСЕ налоги к уплате (транспортный, земельный, на имущество и т.д.)

Для каждого налога извлеки:
- Вид налога (транспортный налог, налог на имущество физических лиц и т.д.)
- Налоговый период (год)
- Сумма исчисленного налога

JSON:
{
        "Номер": "...",
        "Дата": "ДД.ММ.ГГГГ",
        "ФИО": "...",
        "ИНН": "...",
        "Срок_уплаты": "ДД.ММ.ГГГГ",
        "Налоги": [
                {
                        "Вид": "Транспортный налог/Налог на имущество физических лиц/...",
                        "Период": "ГГГГ",
                        "Сумма": "число в рублях"
                }
        ],
        "Всего_к_уплате": "число в рублях"
}
Пустые значения = null. Без комментариев.""",
        },
        "доходы": {
            "keywords": ["2-ндфл", "кнд 1175018", "справка о доходах"],
            "prompt": """Справка о доходах и суммах налога физического лица (форма 2-НДФЛ / КНД 1175018). В одном PDF обычно несколько страниц — каждая за отдельный год.

ВАЖНО: Собери информацию за ВСЕ годы, но при расчётах учитывай, что АКТУАЛЕН последний (самый свежий) год.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (названия организаций с заглавной буквы).

Для каждой страницы определи:
- Год и дату выдачи: строка "за ..." + дата справа.
- Раздел 1: название налогового агента, ИНН, КПП, ОКТМО, телефон.
- Раздел 2: ФИО налогоплательщика, его ИНН, статус, код документа, серия и номер паспорта, дата рождения.
- Раздел 5: общая сумма дохода, налоговая база, налог исчисленный, налог удержанный, налог перечисленный.
- Раздел 6 (если есть): суммы дохода и налога, которые не удержаны.
Если OCR не видит таблицу, используй структуру формы — разделы нумеруются и расположены в одинаковых местах.

Верни JSON:
{
        "ФИО": "...",
        "ИНН": "...",
        "Справки": [
                {
                        "Год": "2021",
                        "Дата_выдачи": "ДД.ММ.ГГГГ",
                        "Налоговый_агент": {
                                "Название": "...",
                                "ИНН": "...",
                                "КПП": "...",
                                "ОКТМО": "...",
                                "Телефон": "..."
                        },
                        "Документ_личности": {
                                "Код": "...",
                                "Серия_номер": "..."
                        },
                        "Общая_сумма_дохода": "...",
                        "Налоговая_база": "...",
                        "Налог_исчисленный": "...",
                        "Налог_удержанный": "...",
                        "Налог_перечисленный": "...",
                        "Неудержанный_доход": "...",
                        "Неудержанный_налог": "..."
                }
        ]
}
Справки должны быть отсортированы по году (от старых к новым). Если какого-то раздела нет, ставь null. Никаких пояснений.""",
        },
        "трудовая": {
            "keywords": ["трудов", "сзв", "трудовой деятельности", "сведения о трудовой", "трудовая книжка", "сзв-стаж", "сзв-м", "сфр", "пфр", "сведения о трудовой деятельности"],
            "prompt": """Документ СФР "Сведения о трудовой деятельности" (форма СТД-Р/СТД-ПФР).

ВАЖНО: Определи АКТУАЛЬНОЕ место работы!
- Если последняя запись — "Увольнение", значит человек сейчас НЕ работает.
- Если последняя запись — "Приём" или "Перевод", значит человек работает в этой организации.
- Игнорируй записи с отметкой "Отмена" — они недействительны.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (названия организаций, должности с заглавной).

Собери:
- ФИО, дата рождения, СНИЛС из шапки.
- Таблицу записей: для каждой строки укажи работодателя, регистрационный номер СФР, дату события, действие (приём/перевод/увольнение), должность/трудовую функцию, реквизиты документа, признак отмены.
- Раздел "Сведения о трудовой деятельности за периоды до 31 декабря 2019 года" — перечисли периоды текстом.
- Определи актуальное место работы: если последнее событие не "Увольнение" — укажи название работодателя и должность в поле "Текущая_работа".
Если OCR слабый, ориентируйся на заголовок "Сведения о трудовой деятельности зарегистрированного лица" — сразу после него таблица с колонками 1-11.

JSON:
{
        "ФИО": "...",
        "Дата_рождения": "ДД.ММ.ГГГГ",
        "СНИЛС": "...",
        "Текущая_работа": "Название организации, Должность" или null (если уволен),
        "Записи": [
                {
                        "Работодатель": "...",
                        "РегНомер": "...",
                        "Дата": "ДД.ММ.ГГГГ",
                        "Событие": "Приём/Перевод/Увольнение",
                        "Должность": "...",
                        "Документ": "...",
                        "Отмена": false
                }
        ],
        "Периоды_до_2019": ["..."]
}
Записи должны быть отсортированы по дате (от старых к новым). Отсутствующие данные = null. Без комментариев.""",
        },
        "счета": {
            "keywords": ["справка о счетах", "счета", "банков", "номер счета", "расчетный счет"],
            "prompt": """Справка о банковских счетах клиента.

ВАЖНО: Включай только АКТИВНЫЕ счета!
- Если в статусе указано "Закрыт", "Закрыт по инициативе клиента", "Расторгнут" — НЕ включай в список.
- Включай только счета со статусом "Открыт", "Активен", "Действующий" и подобными.

Определи:
- Организация, выдавшая документ (шапка или подпись).
- ФИО клиента и дата рождения, если указаны.
- Дата выдачи и исходящий номер (обычно рядом с подписью или заголовком).
- Таблица со счетами: банк, тип счёта (расчётный, депозитный, карточный), номер/IBAN, валюта, дата открытия, статус, остаток, дополнительные отметки.
При скане без текста ориентируйся на типовую структуру таблицы с колонками "Банк"/"Номер счёта"/"Статус".

JSON:
{
        "Организация": "...",
        "ФИО": "...",
        "Дата_выдачи": "ДД.ММ.ГГГГ",
        "Счета": [
                {
                        "Банк": "...",
                        "Тип": "...",
                        "Номер": "...",
                        "Валюта": "...",
                        "Дата_открытия": "ДД.ММ.ГГГГ",
                        "Статус": "...",
                        "Остаток": "..."
                }
        ]
}
В массив "Счета" включай ТОЛЬКО активные счета. Если данных нет — null, списки допускают []. Никаких комментариев.""",
        },
        "егрн_уведомление": {
            "keywords": ["уведомление об отсутствии", "кви-001", "отсутствуют сведения", "отсутствие сведений", "информация отсутствует"],
            "prompt": """Уведомление Росреестра об ОТСУТСТВИИ запрошенных сведений из ЕГРН.

ВНИМАНИЕ: Это НЕ выписка о недвижимости!
- Уведомление = документ о том, что данных НЕТ
- Если видишь "в ЕГРН отсутствуют сведения", "данные не найдены", "сведения отсутствуют" — это уведомление
- Если есть конкретный объект с кадастровым номером — это выписка, не уведомление

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО, адреса с заглавной).

Найди:
- Номер и дату уведомления (в правом верхнем блоке).
- Кому адресовано (заявитель/представитель).
- Вид запрошенной информации, указанный в пункте 1.
- Правообладатель (о ком запрашивались сведения): ФИО, дата рождения, паспорт, СНИЛС, адрес.
- Период, за который запрашивались сведения.
- Территория (где искали).
- Итог: "в ЕГРН отсутствуют сведения" — зафиксируй как результат.
При сканах без текста ориентируйся: основной блок слева, таблица с пунктами 1-2 содержит параметры запроса.

JSON:
{
        "Номер": "...",
        "Дата": "ДД.ММ.ГГГГ",
        "Адресат": "...",
        "Вид_запроса": "...",
        "Период": {
                "С": "ДД.ММ.ГГГГ",
                "По": "ДД.ММ.ГГГГ"
        },
        "Территория": "...",
        "Правообладатель": {
                "ФИО": "...",
                "Дата_рождения": "ДД.ММ.ГГГГ",
                "Паспорт": "...",
                "СНИЛС": "...",
                "Адрес": "..."
        },
        "Результат": "сведения отсутствуют"
}

ВАЖНО: "Результат" должен быть "сведения отсутствуют" — это главный признак уведомления.
Пустые поля = null. Никаких комментариев."""
        },
        "егрн_выписка": {
            "keywords": ["выписка из единого государственного реестра недвижимости", "сведения из егрн", "кадастровый номер", "кадастровая стоимость", "объекта недвижимости", "сведения егрн", "егрн", "реестр недвижимости", "росреестр", "единый государственный реестр недвижимости", "право собственности", "выписка росреестр"],
            "prompt": """Выписка из ЕГРН с ПОДРОБНЫМИ характеристиками объекта недвижимости.

ВНИМАНИЕ: Отличай от уведомления об отсутствии!
- Если видишь "в ЕГРН отсутствуют сведения" или "данные не найдены" — это УВЕДОМЛЕНИЕ, не выписка!
- ВЫПИСКА содержит КОНКРЕТНЫЙ объект с кадастровым номером, адресом, площадью, стоимостью, правообладателями.
- Если в документе нет конкретного объекта недвижимости — это уведомление об отсутствии.

ЧТО ИСКАТЬ В ВЫПИСКЕ:
1. ОБЯЗАТЕЛЬНО должен быть кадастровый номер (формат: XX:XX:XXXXXXX:XXXX)
2. Характеристики объекта: адрес, площадь, назначение
3. Правообладатели с ФИО или названием организации
4. Кадастровая стоимость

ВАЖНО: Показывай только АКТУАЛЬНЫХ правообладателей!
- Если в разделе "Правообладатели" есть отметки "Право прекращено", "Собственность прекращена" — НЕ включай их.
- Включай только записи с текущими (действующими) правами собственности.
- Если права изменились (продажа, дарение) — указывай только последнего (текущего) владельца.
- ОБЯЗАТЕЛЬНО извлеки информацию о смене собственников, если она есть в документе!

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО, адреса с заглавной).

РАБОТА С АДРЕСАМИ ОБЪЕКТОВ:
- Адрес недвижимости может быть размыт или написан ЗАГЛАВНЫМИ БУКВАМИ - это нормально!
- Ищи компоненты: регион/область, город/населенный пункт, улица, дом, корпус, квартира/помещение
- Ключевые слова: "УЛ.", "Д.", "ДОМ", "КОРП.", "СТРОЕНИЕ", "СТР.", "КВ.", "ПОМ.", "ОФИС"
- Формат адреса: "г. Челябинск, ул. Красномолотова, д. 65, корп. 1, кв. 35"
- Даже если текст размыт - разбирай по частям: город + улица минимум
- Числа (номера домов, квартир) обычно читаются лучше названий улиц
- Приводи CAPS LOCK к нормальному виду: "г. Челябинск", а не "Г. ЧЕЛЯБИНСК"
- НЕ оставляй "Адрес" пустым (null) если хотя бы город и улица читаются!

ОСОБЕННОСТИ РАСПОЗНАВАНИЯ:
- ВСЕГДА ищи кадастровый номер - он обычно в начале документа в формате XX:XX:XXXXXXX:XXXX
- Если документ многостраничный - проверь ВСЕ страницы на наличие объектов
- В одной выписке может быть НЕСКОЛЬКО объектов - извлекай все
- Площадь может быть указана как "общая", "жилая", "земли" - берм общую
- Стоимость ищи в разделах "Кадастровая стоимость" или "Рыночная стоимость"
- Если видишь таблицу с несколькими правообладателями - извлеки всех с их долями

Извлеки:
- Кадастровый номер (ОБЯЗАТЕЛЬНО!) и номер квартала.
- Вид объекта (жильё, земельный участок, помещение и т.п.), адрес, площадь, назначение, количество этажей, материал стен, год постройки.
- Кадастровая стоимость.
- Сведения о правообладателях: ФИО/организация, доля, вид права, документ-основание, дата регистрации.
- Если есть блок "Ограничения/обременения" — перенеси ТОЛЬКО действующие обременения (игнорируй "погашено", "прекращено").
- СДЕЛКА: если видишь смену собственников, переход права — извлеки дату, стороны сделки, основание (купля-продажа, дарение и т.д.).
При отсутствии распознанного текста ориентируйся на таблицы: первая колонка название реквизита, вторая значение.

JSON:
{
        "Кадастровый_номер": "...",
        "Кадастровый_квартал": "...",
        "Объект": {
                "Вид": "...",
                "Адрес": "...",
                "Площадь": "...",
                "Назначение": "...",
                "Этажность": "...",
                "Материал_стен": "...",
                "Год_постройки": "..."
        },
        "Кадастровая_стоимость": "...",
        "Правообладатели": [
                {
                        "ФИО": "...",
                        "Доля": "...",
                        "Вид_права": "...",
                        "Документ": "...",
                        "Дата_регистрации": "ДД.ММ.ГГГГ"
                }
        ],
        "Обременения": ["..."],
        "Предыдущие_собственники": [
                {
                        "ФИО": "...",
                        "Дата_прекращения_права": "ДД.ММ.ГГГГ",
                        "Основание_прекращения": "купля-продажа/дарение/другое"
                }
        ],
        "Сделка": {
                "Есть_сделка": true/false,
                "Тип_сделки": "купля-продажа/дарение/наследование/другое",
                "Дата_сделки": "ДД.ММ.ГГГГ",
                "Предыдущий_собственник": "...",
                "Новый_собственник": "...",
                "Стоимость": 0.00
        }
}

ОБРЕМЕНЕНИЯ И ЗАЛОГОДЕРЖАТЕЛИ:
- Ищи раздел "Сведения о правах и обременениях" или "Записи об обременениях"
- Типы обременений: ипотека, залог, аренда, арест, запрещение сделок
- Залогодержатель/банк может быть указан полным названием: "АО «Челябинвестбанк»", "ПАО Сбербанк"
- Может быть указан кратко: "Банк ВТБ", "Т-Банк", "Альфа-Банк"
- Обращай внимание на слова: "залогодержатель", "кредитор", "банк", "в пользу"
- Если обременение "погашено" или "прекращено" - укажи в поле "Погашено": true
- В каждом обременении ОБЯЗАТЕЛЬНО указывай залогодержателя/кредитора если он упоминается

КРИТИЧЕСКИ ВАЖНО:
- Если НЕТ кадастрового номера или написано "сведения отсутствуют" — верни {"Результат": "сведения отсутствуют"}
- В "Правообладатели" и "Обременения" включай ТОЛЬКО актуальные (действующие) записи
- Если видишь переход права собственности — заполни "Сделка" с "Есть_сделка": true
- Поля без данных = null, списки допускают []
- Комментарии не добавляй"""
        },
        "пенсии": {
            "keywords": ["справка сфр", "назначенных пенсиях", "ежемесячной денежной выплаты", "едв"],
            "prompt": """Справка СФР о назначенных пенсиях и социальных выплатах.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (названия с заглавной).

Определи:
- СНИЛС, ФИО, дату рождения (в шапке рядом с номером дела).
- Орган, выдавший справку, номер и дату.
- Перечень назначенных выплат: название выплаты, правовое основание (статья закона), период установления, размер, статус НСУ (лекарства, санаторий, проезд).
- Размер ежемесячной денежной выплаты (ЕДВ) и волеизъявление по набору социальных услуг.
- Цель выдачи/основание (внизу документа).
Если OCR пустой, знай: шапка содержит номер, СНИЛС и дату рождения, таблица выплат расположена в середине.

JSON:
{
        "ФИО": "...",
        "СНИЛС": "...",
        "Дата_рождения": "ДД.ММ.ГГГГ",
        "Номер_справки": "...",
        "Дата_справки": "ДД.ММ.ГГГГ",
        "Орган": "...",
        "Выплаты": [
                {
                        "Вид": "...",
                        "Основание": "...",
                        "Период": {
                                "С": "ДД.ММ.ГГГГ",
                                "По": "ДД.ММ.ГГГГ"/"бессрочно"
                        },
                        "Размер": "...",
                        "НСУ": {
                                "Лекарства": "...",
                                "Санаторий": "...",
                                "Проезд": "..."
                        }
                }
        ],
        "ЕДВ": "...",
        "Основание_выдачи": "..."
}
Если поля отсутствуют — null. Комментарии не добавляй.""",
        },
        "выплаты": {
            "keywords": ["справка о выплатах", "сфр", "выплатах за период", "ежемесячная денежная"],
            "prompt": """Справка СФР о выплатах за период.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Фиксируй:
- ФИО, СНИЛС, дату рождения (шапка документа).
- Орган СФР, номер, дату справки.
- Период, за который предоставлены данные ("в период с ... по ...").
- Таблицу выплат: название выплаты, правовое основание, период назначения, размер, НСУ (если указано), фактические выплаты по месяцам.
- Итоговые суммы.
Если OCR пустой, ориентируйся на таблицу с колонками "Наименование выплаты", "Основания", "Период", "Размер".

JSON:
{
        "ФИО": "...",
        "СНИЛС": "...",
        "Дата_рождения": "ДД.ММ.ГГГГ",
        "Номер_справки": "...",
        "Дата_справки": "ДД.ММ.ГГГГ",
        "Орган": "...",
        "Период": {
                "С": "ДД.ММ.ГГГГ",
                "По": "ДД.ММ.ГГГГ"
        },
        "Выплаты": [
                {
                        "Наименование": "...",
                        "Основание": "...",
                        "Период": {
                                "С": "ДД.ММ.ГГГГ",
                                "По": "ДД.ММ.ГГГГ"/"бессрочно"
                        },
                        "Размер": "...",
                        "НСУ": "...",
                        "Комментарии": "..."
                }
        ]
}
Пустые значения = null. Без комментариев.""",
        },
        "отчет_окб": {
            "keywords": ["кредитный отчет", "окб", "объединенное кредитное бюро", "объединенного кредитного бюро", "кредитная история", "отчет окб", "бюро кредитных историй"],
            "prompt": """Найди таблицу "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ" или "АКТИВНЫЕ ДОГОВОРЫ".

Для КАЖДОЙ строки таблицы:
1. Название кредитора (например: МТС-БАНК ПАО)
2. Найди детальный раздел НИЖЕ с этим кредитором и извлеки:
   - "Дата совершения сделки" или "Дата возникновения обязательства"
   - "Сумма и валюта обязательства" (ОБЯЗАТЕЛЬНО! первоначальная сумма кредита)
   - Тип кредита/займа (из колонки "Вид обязательства" или аналогичной: Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, Необеспеченный кредит, и т.д.)
   - В таблице "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ" колонка "Общая задолженность":
     Возьми значение из колонки "Общая задолженность" = текущий долг

КРИТИЧЕСКИ ВАЖНО ПРО ДОЛГ В ОКБ:
- Используй ТОЛЬКО "Общая задолженность" из таблицы "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ"
- "Общая задолженность" УЖЕ ВКЛЮЧАЕТ просрочку, проценты и всё остальное!
- В разделе "Сведения об источнике" ищи строку "ИНН и ОГРН (ОГРНИП)". Там будет текст вида: "ИНН³ 7744000912" и строкой ниже "ОГРН 1027739019142"
- ИНН - это число из строки с пометкой "ИНН³" (10 цифр). ОБЯЗАТЕЛЬНО извлеки его!
- ОГРН НЕ НУЖЕН (это 13 цифр)
- ИЛИ сложи "Основной долг" + "Проценты" + "Иное" из детального раздела НИЖЕ в таблице "Сведения о сумме задолженности"
- НЕ суммируй "Общая задолженность + Просроченная задолженность" в таблице ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ!
- Просто возьми значение "Общая задолженность" как есть

JSON:
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "ИНН_кредитора": "число из строки 'ИНН³' в разделе 'Сведения об источнике' (10 цифр, например: 7744000912)",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "ДД.ММ.ГГГГ",
      "Сумма_обязательства": "первоначальная сумма",
      "Сумма": "значение из 'Общая задолженность' (НЕ складывать!)"
    }}
  ]
}}""",
        },
        "отчет_бки": {
            "keywords": ["скоринг", "бки", "индивидуальный рейтинг", "кредитная история", "бюро кредитных историй", "кредитный рейтинг", "отчет бки", "скоринговый балл"],
            "prompt": """

Найди таблицу "АКТИВНЫЕ ДОГОВОРЫ".

Для КАЖДОЙ строки таблицы извлеки:
- Кредитор (точное название из колонки)
- Тип кредита/займа (из колонки "Вид обязательства" или аналогичной: Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, Необеспеченный кредит, и т.д.)
- Дата начала договора (из колонки "Дата начала договора")
- Сумма обязательства по договору (ОБЯЗАТЕЛЬНО! из колонки "Сумма обязательства по договору" - первоначальная сумма кредита)
- Текущий долг = "Текущая задолженность" + "Текущая просрочка, сумма"

ВАЖНО: 
- "Сумма обязательства по договору" - это первоначальная сумма кредита, НЕ текущий долг!
- Поле в JSON ОБЯЗАТЕЛЬНО должно называться "Кредиты", НЕ "Договоры"!
- В БКИ отчёте НЕТ ИНН кредитора, поэтому НЕ извлекай его!

JSON (СТРОГО этот формат):
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "дата",
      "Сумма_обязательства": "первоначальная сумма из колонки",
      "Сумма": "текущая задолженность + просрочка"
    }}
  ]
}}""",
        },
        "отчет_нбки": {
            "keywords": ["нбки", "национальное бюро кредитных историй", "кредитный отчет для субъекта", "кредитная история нбки", "nbch", "отчет нбки"],
            "prompt": """

Найди раздел с заголовком "Обязательства и их исполнение" - там начинается список кредиторов.

Для КАЖДОГО кредитора:
1. Название банка/кредитора (заголовок раздела)
2. В таблице "Основные сведения об обязательстве":
   - Столбец "Сумма и валюта обязательства" = первоначальная сумма займа (Сумма_обязательства)
   - Столбец "Дата возникновения обязательства" = дата сделки (Дата_сделки)
   - Столбец "ОГРН/ИНН" - там два числа через пробел. ПЕРВОЕ (13 цифр) - это ОГРН, НЕ НУЖНО. ВТОРОЕ (10 цифр) - это ИНН, ОБЯЗАТЕЛЬНО извлеки!
   - Тип кредита/займа (из строки "Вид обязательства" или аналогичной: Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, и т.д.)
3. В таблице "Задолженность":
   - Найди САМУЮ ПОСЛЕДНЮЮ строку в таблице
   - Возьми значение из столбца "Сумма" (это текущий долг)
   - ИГНОРИРУЙ другие столбцы ("Сумма по осн.долгу", "Сумма по %%", и т.д.)

КРИТИЧЕСКИ ВАЖНО:
- Берем ТОЛЬКО последнюю строку таблицы "Задолженность"
- Берем ТОЛЬКО столбец "Сумма" из этой строки
- Это и есть текущий долг
- НЕ суммируем ничего, просто берем одно значение!
- В столбце "ОГРН/ИНН" берем ВТОРОЕ число (10 цифр) - это ИНН!

JSON (СТРОГО этот формат):
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "ИНН_кредитора": "ВТОРОЕ число из столбца ОГРН/ИНН (10 цифр)",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "ДД.ММ.ГГГГ",
      "Сумма_обязательства": "первоначальная сумма",
      "Сумма": "последняя строка таблицы Задолженность, столбец Сумма"
    }}
  ]
}}""",
        },
        "гибдд": {
            "keywords": ["гибдд", "гаи", "транспорт", "птс", "стс", "свидетельство о регистрации тс", "паспорт транспортного средства", "автомобил", "мрэо", "госавтоинспекция", "государственная инспекция безопасности дорожного движения", "транспортное средство", "регистрация тс", "мвд"],
            "prompt": """Документ ГИБДД о транспортном средстве (ПТС, СТС, выписка из реестра, договор купли-продажи).

ВНИМАНИЕ:
- Если это ДОГОВОР КУПЛИ-ПРОДАЖИ — машина УЖЕ ПРОДАНА! В "Особые_отметки" напиши "Продано по договору от [дата]"
- Если написано "снято с учета", "продажа", "передача" — ОБЯЗАТЕЛЬНО укажи в "Особые_отметки"
- ОБЯЗАТЕЛЬНО извлеки информацию о сделке, если она есть в документе!

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Найди:
- Марку, модель, VIN, государственный регистрационный номер.
- Год выпуска, цвет, номер кузова/шасси.
- Тип ТС (легковой, грузовой, мотоцикл).
- Собственник: ФИО, адрес регистрации.
- Дата регистрации, номер и серия документа.
- Особые отметки (ограничения, залог, арест, СНЯТО С УЧЕТА, ПРОДАНО).
- СДЕЛКА (если есть): тип (купля-продажа, дарение), дата, вторая сторона (покупатель/продавец), стоимость.

РАБОТА С АДРЕСОМ СОБСТВЕННИКА:
- Адрес регистрации владельца ТС может быть размыт или в CAPS LOCK - это нормально!
- Формат адреса: город, улица, дом, корпус (если есть), квартира
- Ищи ключевые слова: "ГОР.", "Г.", "УЛ.", "Д.", "ДОМ", "КВ.", "КОРП."
- Приводи к нормальному виду: "г. Челябинск, ул. Ленина, д. 1, кв. 10"
- Даже если текст размыт - разбирай по частям (город + улицу минимум)
- Числа (номера домов, квартир) обычно читаются лучше названий улиц
- НЕ оставляй адрес пустым если хотя бы город читается!

JSON:
{
        "Тип_ТС": "легковой/грузовой/мотоцикл/...",
        "Марка_модель": "...",
        "VIN": "...",
        "Гос_номер": "...",
        "Год_выпуска": "ГГГГ",
        "Цвет": "...",
        "Номер_кузова": "...",
        "Собственник": {
                "ФИО": "...",
                "Адрес": "..."
        },
        "Документ": {
                "Тип": "ПТС/СТС/выписка/договор купли-продажи",
                "Серия_номер": "...",
                "Дата_регистрации": "ДД.ММ.ГГГГ"
        },
        "Особые_отметки": "...",
        "Сделка": {
                "Есть_сделка": true/false,
                "Тип_сделки": "купля-продажа/дарение/другое",
                "Дата_сделки": "ДД.ММ.ГГГГ",
                "Покупатель_ФИО": "...",
                "Продавец_ФИО": "...",
                "Стоимость": 0.00
        }
}

ВАЖНО: Если это договор купли-продажи ТС или есть информация о передаче права собственности:
- "Есть_сделка": true
- Заполни все поля "Сделка"
Если обычное СТС/ПТС без сделки:
- "Есть_сделка": false
- "Сделка" можно оставить null

Пустые значения = null. Без комментариев.""",
        },
        "учредитель": {
            "keywords": ["егрюл", "учредитель", "устав", "участник", "доля", "акционер", "выписка из егрюл"],
            "prompt": """Документ об учредительстве или участии в организации (выписка ЕГРЮЛ, устав, список акционеров, договор об учреждении).

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Найди:
- Полное название организации, ИНН, ОГРН.
- Форма собственности (ООО, ОАО, ЗАО и т.д.).
- ФИО участника/учредителя.
- Размер доли/количество акций (в процентах или номинале).
- Номинальная стоимость доли/акций.
- Дата внесения записи/регистрации.
- Адрес регистрации организации.

JSON:
{
        "Организация": {
                "Название": "...",
                "ИНН": "...",
                "ОГРН": "...",
                "Форма": "ООО/ОАО/ЗАО/...",
                "Адрес": "..."
        },
        "Участник": {
                "ФИО": "...",
                "Доля": "...%/... акций",
                "Номинальная_стоимость": "... руб.",
                "Дата_регистрации": "ДД.ММ.ГГГГ"
        }
}
Если участников несколько — верни массив в поле "Участники". Пустые значения = null. Без комментариев.""",
        },
        "ценные_бумаги": {
            "keywords": ["депозитарий", "брокер", "счет депо", "ценные бумаги", "акции", "облигации", "паи", "инвестиционный счет"],
            "prompt": """Выписка из депозитария или брокерский отчет о ценных бумагах.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Найди:
- Владелец (ФИО, паспорт или ИНН).
- Депозитарий/брокер, номер счета депо/брокерского счета.
- Дата формирования отчета/выписки, период.
- Перечень ценных бумаг: наименование эмитента, тип (акция/облигация/пай/...), количество, номинал, текущая стоимость, ISIN.
- Общая стоимость портфеля.

JSON:
{
        "Владелец": {
                "ФИО": "...",
                "Паспорт": "...",
                "ИНН": "..."
        },
        "Депозитарий": "...",
        "Номер_счета": "...",
        "Дата_выписки": "ДД.ММ.ГГГГ",
        "Период": "с ... по ...",
        "Ценные_бумаги": [
                {
                        "Эмитент": "...",
                        "Тип": "акция/облигация/пай/...",
                        "ISIN": "...",
                        "Количество": ...,
                        "Номинал": "...",
                        "Текущая_стоимость": "..."
                }
        ],
        "Общая_стоимость": "..."
}
Пустые значения = null, списки допускают []. Без комментариев.""",
        },
        "имущественные_права": {
            "keywords": ["договор займа", "дебиторская", "акт сверки", "задолженность", "право требования", "договор аренды"],
            "prompt": """Документ об имущественных правах (договор займа, акт сверки, решение суда о взыскании, договор аренды с правом получения платы).

КРИТИЧЕСКИ ВАЖНО - ОПРЕДЕЛЕНИЕ РОЛИ:
Это имущественное право ТОЛЬКО если владелец документа = КРЕДИТОР (займодавец, арендодатель).
Если владелец документа = ДОЛЖНИК (заёмщик, арендатор) - это НЕ имущественное право, а ОБЯЗАТЕЛЬСТВО!

Проверь:
1. Кто даёт деньги/имущество? → КРЕДИТОР (займодавец, арендодатель)
2. Кто получает деньги/имущество? → ДОЛЖНИК (заёмщик, арендатор)

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Найди:
- Тип документа (договор займа/акт сверки/решение суда/договор аренды).
- Стороны: 
  * Кредитор (займодавец, арендодатель) - кто ДАЁТ деньги/имущество
  * Должник (заёмщик, арендатор) - кто ПОЛУЧАЕТ деньги/имущество
- Номер договора/дела, дата.
- Сумма задолженности/ежемесячной платы.
- Срок возврата/период аренды.
- Особые условия (проценты, неустойка, график платежей).

JSON:
{
        "Тип": "договор займа/акт сверки/решение суда/договор аренды",
        "Номер": "...",
        "Дата": "ДД.ММ.ГГГГ",
        "Кредитор": "ФИО займодавца/арендодателя (кто ДАЁТ деньги)",
        "Должник": "ФИО заёмщика/арендатора (кто ПОЛУЧАЕТ деньги)",
        "Роль_владельца_документа": "кредитор/должник",
        "Сумма": "...",
        "Срок": "...",
        "Условия": "..."
}
Пустые значения = null. Без комментариев.""",
        },
        "справка_о_задолженности": {
            "keywords": ["справка о задолженности", "задолженность перед", "сумма задолженности", "размер долга", "справка о задолженности перед"],
            "prompt": """Справка о задолженности перед кредитором (банк, МФО, МКК).

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Найди:
- Кредитор: полное название организации (ООО МКК "...", ПАО "...", АО "...").
- Должник: ФИО.
- Номер договора/счета.
- Дата выдачи справки.
- Сумма основного долга (тело кредита).
- Проценты/пени (если указаны отдельно).
- ИТОГОВАЯ СУММА ЗАДОЛЖЕННОСТИ (основной долг + проценты + пени).
- Дата возникновения задолженности, в большинстве написано так: "...был заключен договор потребительского займа от 17.09.2024..."

КРИТИЧЕСКИ ВАЖНО: Ищи ИТОГОВУЮ сумму! Она может быть обозначена как:
- "Общая сумма задолженности"
- "Итого к погашению"
- "Размер задолженности"
- "Сумма долга на дату"

JSON:
{
        "Кредитор": "...",
        "Должник": "...",
        "Номер_договора": "...",
        "Дата_справки": "ДД.ММ.ГГГГ",
        "Основной_долг": 12345.67,
        "Проценты": 1234.56,
        "Пени": 123.45,
        "Итого_задолженность": 13703.68,
        "Дата_возникновения": "ДД.ММ.ГГГГ"
}

ВАЖНО: Суммы указывай ТОЛЬКО числами (без "руб.", без пробелов). Если сумма не указана - ставь null.
Пустые значения = null. Без комментариев.""",
        },
        "постановление_пристава": {
            "keywords": ["постановление", "постановления", "фссп", "судебный пристав", "судебного пристава", "исполнительное производство", "исполнительном производстве", "взыскание", "пристав", "федеральная служба судебных приставов", "исполнительный лист", "исполнительное производство", "пристав-исполнитель"],
            "prompt": """Постановление судебного пристава-исполнителя о возбуждении исполнительного производства или о расчёте задолженности.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

КРИТИЧЕСКИ ВАЖНО - РАБОТА С СУММАМИ:
В постановлении обычно НЕСКОЛЬКО сумм:
1. Основной долг (сумма взыскания) - главная сумма долга
2. Исполнительский сбор (обычно 7% от суммы долга, минимум 1000 руб.)
3. Расходы по исполнительному производству (если есть)
4. **ИТОГО ВЗЫСКАНИЕ** ← это СУММА всех вышеперечисленных!

Ищи итоговую сумму по ключевым словам:
- "Итого взыскание:"
- "Всего взыскать:"
- "Общая сумма взыскания:"
- "Подлежит взысканию:"

Поле "Итого_взыскание" = основной_долг + исполнительский_сбор + расходы
Если ИТОГО не указано явно - посчитай сам!

Найди:
- Номер исполнительного производства.
- Дата постановления.
- Судебный пристав: ФИО, отдел ФССП.
- Должник: ФИО.
- Взыскатель (кредитор): название организации или ФИО.
- Адрес взыскателя (если указан).
- Предмет исполнения: описание долга (например: "Задолженность по кредитным платежам (кроме ипотеки)").
- Основание: исполнительный лист, судебный приказ (номер, дата).
- Орган, выдавший исполнительный документ (например: "Судебный участок № 9 Калининского района г. Челябинска").
- Адрес органа.
- Номер дела.
- Сумма взыскания (основной долг).
- Исполнительский сбор (если есть).
- Расходы по исполнительному производству (если есть).
- ИТОГОВАЯ СУММА ВЗЫСКАНИЯ (ОБЯЗАТЕЛЬНО!).

JSON:
{
        "Номер_ИП": "...",
        "Дата_постановления": "ДД.ММ.ГГГГ",
        "Пристав": "...",
        "Отдел_ФССП": "...",
        "Должник": "...",
        "Взыскатель": "...",
        "Адрес_взыскателя": "...",
        "Предмет_исполнения": "...",
        "Основание": "...",
        "Номер_основания": "...",
        "Дата_основания": "ДД.ММ.ГГГГ",
        "Орган_выдавший": "...",
        "Адрес_органа": "...",
        "Номер_дела": "...",
        "Сумма_долга": 12345.67,
        "Исполнительский_сбор": 1234.56,
        "Расходы": 123.45,
        "Итого_взыскание": 13703.68
}

ВАЖНО: Суммы указывай ТОЛЬКО числами. Если сумма не указана - ставь null.
Пустые значения = null. Без комментариев.""",
        },

        "ценное_имущество": {
            "keywords": ["драгоценности", "ювелирные изделия", "золото", "серебро", "украшения", "антиквариат", "картины", "коллекция", "предметы искусства", "опись имущества", "оценка имущества", "акт оценки"],
            "prompt": """Документ о наличных денежных средствах и ином ценном имуществе (опись имущества, акт оценки, декларация о наличии ценностей).

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Найди:
- Владелец (ФИО).
- Наличные денежные средства (если указаны): сумма в рублях и/или валюте.
- Драгоценности и ювелирные изделия: описание (золотое кольцо, серьги и т.д.), вес/проба, оценочная стоимость.
- Предметы искусства и антиквариат: описание, автор, год, оценочная стоимость.
- Коллекции: описание (монеты, марки, часы), количество предметов, оценочная стоимость.
- Дорогая техника и электроника: описание, марка/модель, год, стоимость.
- Другое ценное имущество: описание, стоимость.
- Дата оценки/составления описи.
- Оценщик (если есть): ФИО, организация.

JSON:
{
        "Владелец": "...",
        "Дата_составления": "ДД.ММ.ГГГГ",
        "Оценщик": "...",
        "Наличные_средства": {
                "RUB": "...",
                "USD": "...",
                "EUR": "...",
                "Другая_валюта": "..."
        },
        "Имущество": [
                {
                        "Категория": "драгоценности/искусство/коллекция/техника/другое",
                        "Описание": "...",
                        "Характеристики": "...",
                        "Оценочная_стоимость": "..."
                }
        ],
        "Общая_стоимость": "..."
}
Пустые значения = null, списки допускают []. Без комментариев.""",
        },

        "сделки": {
            "keywords": ["договор купли-продажи", "договор дарения", "договор мены", "договор купли продажи", "покупатель", "продавец", "даритель", "одаряемый", "недвижимое имущество", "транспортное средство", "автомобиль", "квартира", "дом", "земельный участок", "акт приема-передачи"],
            "prompt": """Ты обрабатываешь документы о сделках должника за последние 3 года: договоры купли-продажи, дарения, мены недвижимости, транспортных средств и иного ценного имущества.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду.

Найди:
- Тип сделки: купля-продажа, дарение, мена, другое.
- Дата сделки (дата подписания договора).
- Роль должника: покупатель, продавец, даритель, одаряемый, и т.д.
- Предмет сделки: что продано/куплено/подарено (квартира, дом, земельный участок, автомобиль, и т.д.).
- Описание предмета: адрес недвижимости, марка/модель ТС, кадастровый номер, другие характеристики.
- Стоимость сделки (сумма в рублях).
- Вторая сторона сделки: ФИО покупателя/продавца/другой стороны.
- Особые условия: рассрочка, кредит, обременения, и т.д.

КРИТЕРИИ ОТБОРА:
- Анализируй ТОЛЬКО документы о сделках за последние 3 года от текущей даты.
- Сделки с недвижимостью: квартиры, дома, земельные участки, гаражи, нежилые помещения.
- Сделки с транспортом: автомобили, мотоциклы, спецтехника.
- Сделки с иным ценным имуществом (любой стоимости).

JSON:
{
        "Тип_сделки": "купля-продажа/дарение/мена/другое",
        "Дата_сделки": "ДД.ММ.ГГГГ",
        "Роль_должника": "покупатель/продавец/даритель/одаряемый",
        "Предмет_сделки": "квартира/дом/земельный участок/автомобиль/другое",
        "Описание": "...",
        "Адрес_или_характеристики": "...",
        "Кадастровый_номер": "...",
        "Стоимость": 0.00,
        "Вторая_сторона": "ФИО",
        "Особые_условия": "..."
}

Пустые значения = null. Суммы ТОЛЬКО числами. Без комментариев.""",
        },
        
        # === Документы супруга (используют те же промпты что и основные документы) ===
        "паспорт_супруга": {
            "keywords": ["паспорт супруга", "паспорта супруга", "паспорт жены", "паспорта жены", "паспорт мужа", "паспорта мужа", "passport spouse"],
            "prompt": """Ты обрабатываешь паспорт РФ. Извлеки реквизиты максимально точно.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО, адреса с заглавной буквы).

1. Страница 2-3 (основные данные):
   - В верху слева: серия и номер (пример: 1234 567890 — верни как "1234 567890").
   - Ниже "Фамилия", "Имя", "Отчество" — построчно.
   - Дата рождения формата ДД.ММ.ГГГГ.
   - Место рождения:
     - Приведи к официальному виду
     - НЕ убирай "гор.", "с.", "пос.", "д.", "обл.", "респ.", "край"
     - Применяй правила:
       * "ГОР." → "гор." (строчные)
       * "Г МОСКВА" → "гор. Москва" (добавь точку)
       * "Г.МОСКВА" → "гор. Москва" (пробел)
       * "ГОР МОСКВА" → "гор. Москва"
       * "С. БОЛЬШОЕ" → "с. Большое"
       * "Д КРАСНОЕ" → "д. Красное" (добавь точку)
       * "ПОС.ЮЖНЫЙ" → "пос. Южный" (пробел)
     - Примеры правильных форматов:
       * "гор. Москва"
       * "с. Большое"
       * "д. Красное, Московская обл."
       * "пос. Южный, Краснодарский край"
       * "гор. Санкт-Петербург"
       * "респ. Татарстан, гор. Казань"
     - Если адрес содержит несколько уровней, сохраняй иерархию: "респ. Татарстан, гор. Казань"
   - Пол: "муж" или "жен".
   - Строка "Кем выдан" — название подразделения УФМС/МВД.
   - Дата выдачи: ДД.ММ.ГГГГ.
   - Код подразделения: XXX-XXX.

2. Страница 5 (регистрация):
   - Штамп с адресом (часто размыт или кривой) — попытайся распознать.
   - Адрес регистрации: строковые данные из штампа.
   - Если штамп размыт, используй контекстную логику (первая пропись в паспорте обычно сохраняется).

Если документ старый или новый (2022 г. и позже), алгоритм тот же.

Верни JSON:
{
  "ФИО": "...",
  "Серия_и_номер": "...",
  "Дата_выдачи": "ДД.ММ.ГГГГ",
  "Код_подразделения": "...",
  "Кем_выдан": "...",
  "Дата_рождения": "ДД.ММ.ГГГГ",
  "Место_рождения": "...",
  "Адрес_регистрации": "..."
}
Если реквизит не найден, ставь null. Никаких дополнительных комментариев.""",
        },
        "инн_супруга": {
            "keywords": ["инн супруга", "инна супруга", "инн жены", "инна жены", "инн мужа"],
            "prompt": """Ты обрабатываешь свидетельство о постановке на учёт физического лица (ИНН).

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО с заглавной буквы).

КРИТИЧЕСКИ ВАЖНО - ФОРМАТ ИНН:
ИНН может быть записан по-разному:
- Правильно: 123456789012
- С пробелами: 1234 5678 9012 или 123 456 789 012
- С дефисами: 1234-5678-9012 или 123-456-789-012
- Сгруппированно: (123) 456-789-012
- Частично размыт

ИНСТРУКЦИЯ:
- ИНН ВСЕГДА 12 цифр (физ. лицо) — без пробелов и дефисов
- Ищи ~12 цифр рядом со словами: "ИНН", "Идентификационный номер", "Свидетельство"
- Убери все пробелы, дефисы, скобки
- Приведи к формату: 123456789012
- Если часть цифр размыта - попытайся разобрать хотя бы 10-11 цифр
- НЕ путай с ОГРН (13/15 цифр), СНИЛС (11 цифр), датами, телефонами

СТРУКТУРА ДОКУМЕНТА:
1. Заголовок: "Свидетельство о постановке на учёт физического лица в налоговом органе" или "Свидетельство о постановке на учёт".
2. Серия и номер (не путай с ИНН): обычно формат XX № XXXXXXXXXX (тоже 12 цифр, но в другом месте).
3. ИНН: крупный номер, часто выделен жирным или рамкой — ВСЕГДА 12 цифр.
4. ФИО: блок текста "Фамилия Имя Отчество" или построчно.
5. Подпись и печать налоговой инспекции.

Если OCR пустой, используй визуальную структуру:
- ИНН обычно в центре или сверху справа крупным шрифтом.
- ФИО ниже ИНН.

Верни JSON:
{
  "ФИО": "...",
  "ИНН": "123456789012"
}
Если реквизит не найден, ставь null. Никаких дополнительных комментариев.""",
        },
        "снилс_супруга": {
            "keywords": ["снилс супруга", "снилса супруга", "снилс жены", "снилса жены", "снилс мужа", "снилса мужа"],
            "prompt": """Ты обрабатываешь страховое свидетельство обязательного пенсионного страхования (СНИЛС) — старый зелёный пластик или новая электронная справка.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО, адреса с заглавной буквы).

КРИТИЧЕСКИ ВАЖНО - ФОРМАТЫ СНИЛС:
СНИЛС может быть записан по-разному:
- Правильно: 123-456-789 12
- Слитно: 12345678912
- С пробелами: 123 456 789 12
- Без дефисов: 123 456 789 12
- С точками: 123.456.789.12
- Частично размыт

ИНСТРУКЦИЯ:
- СНИЛС ВСЕГДА 11 цифр в стандартном формате XXX-XXX-XXX XX
- Ищи ~11 цифр рядом со словами: "СНИЛС", "Страховой номер", "СФР"
- Убери все пробелы, дефисы, точки
- Приведи к правильному формату: XXX-XXX-XXX XX (с дефисами между тройками и пробелом перед последней двойкой)
- Если часть цифр размыта - попытайся разобрать хотя бы 9-10 цифр
- НЕ путай с ИНН (12 цифр), телефоном, другими номерами

1. Старый бланк:
        - Заголовок "Страховое свидетельство" и строка "Страховой номер" — формат XXX-XXX-XXX XX.
        - Ниже блок "Фамилия", "Имя", "Отчество".
        - Внизу слева "Дата рождения" и "Место рождения".
        - Под подписью страхователя — дата выдачи.
2. Новая справка СФР:
        - Шапка "Страховой номер индивидуального лицевого счёта" — рядом СНИЛС.
        - Таблица с ФИО, датой и местом рождения.

Если OCR пустой, используй макет: номер крупно в центре, ФИО блоком ниже, дата рождения под ФИО.

Верни JSON:
{
  "ФИО": "...",
  "СНИЛС": "XXX-XXX-XXX XX",
  "Дата_рождения": "ДД.ММ.ГГГГ",
  "Место_рождения": "...",
  "Дата_выдачи": "ДД.ММ.ГГГГ",
  "Тип_бланка": "карта 1997/справка СФР"
}
Если реквизит не найден, ставь null. Никаких дополнительных комментариев.""",
        },

        "свидетельство_о_браке": {
            "keywords": ["свидетельство о заключении брака", "свидетельство о браке", "запись акта о заключении брака", "брак", "супруг", "супруга", "загс"],
            "prompt": """Ты обрабатываешь свидетельство о заключении брака.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО с заглавной буквы).

Найди в документе:
- ФИО супруга (мужа)
- ФИО супруги (жены)
- Дата рождения супруга
- Дата рождения супруги
- Дата заключения брака
- Орган ЗАГС, выдавший свидетельство
- Номер записи акта
- Дата выдачи свидетельства

КРИТИЧЕСКИ ВАЖНО:
- Различай ФИО супруга (мужа) и супруги (жены)
- Обязательно извлеки даты рождения обоих супругов
- Дата заключения брака — это дата регистрации в ЗАГС, не дата выдачи свидетельства

Верни JSON:
{
  "Супруг_ФИО": "ФИО мужа",
  "Супруг_Дата_рождения": "ДД.ММ.ГГГГ",
  "Супруга_ФИО": "ФИО жены",
  "Супруга_Дата_рождения": "ДД.ММ.ГГГГ",
  "Дата_заключения_брака": "ДД.ММ.ГГГГ",
  "Орган_ЗАГС": "...",
  "Номер_записи": "...",
  "Дата_выдачи": "ДД.ММ.ГГГГ"
}

Если реквизит не найден, ставь null. Никаких дополнительных комментариев.""",
        },

        "свидетельство_о_рождении": {
            "keywords": ["свидетельство о рождении", "свидетельство о рождении ребенка", "родился", "родилась", "запись акта о рождении", "ребенок", "загс"],
            "prompt": """Ты обрабатываешь свидетельство о рождении ребенка.

ФОРМАТИРОВАНИЕ: Если текст в CAPS LOCK — приведи к нормальному виду (ФИО с заглавной буквы).

Найди в документе:
- ФИО ребенка (полностью: Фамилия Имя Отчество)
- Дата рождения ребенка
- Место рождения ребенка
- ФИО матери
- ФИО отца
- Орган ЗАГС, выдавший свидетельство
- Номер записи акта
- Дата выдачи свидетельства

КРИТИЧЕСКИ ВАЖНО:
- ФИО ребенка — это основная информация, обязательно извлеки
- Дата рождения ребенка — ОБЯЗАТЕЛЬНОЕ поле для определения несовершеннолетия
- Если отчество ребенка отсутствует — укажи null
- Различай ФИО ребенка, матери и отца

Верни JSON:
{
  "Ребенок_ФИО": "Полное ФИО ребенка",
  "Дата_рождения": "ДД.ММ.ГГГГ",
  "Место_рождения": "...",
  "Мать_ФИО": "...",
  "Отец_ФИО": "...",
  "Орган_ЗАГС": "...",
  "Номер_записи": "...",
  "Дата_выдачи": "ДД.ММ.ГГГГ"
}

Если реквизит не найден, ставь null. Никаких дополнительных комментариев.""",
        },

        "общий": {
            "keywords": [],
            "prompt": """Ты анализируешь произвольный документ.

Определи по содержимому ключевые поля (ФИО, даты, суммы, номера) и верни аккуратный JSON.
Если тип не распознан, верни {"raw_text": "..."} с полным текстом.
Не добавляй комментариев, вывод строго JSON.""",
        },
    }

    # === Utilities ===
    @staticmethod
    def detect_document_type(filename: str, first_page_text: Optional[str] = None) -> tuple[str, str]:
        """Определяет тип документа по имени файла и содержимому.

        Args:
            filename: Имя файла
            first_page_text: Текст первой страницы (для контекстного распознавания)

        Returns:
            Кортеж (тип документа, промпт для GPT)
        """
        # Заменяем подчеркивания на пробелы для лучшего распознавания
        filename_lower = filename.lower().replace('_', ' ')

        # ПРИОРИТЕТ 1: Сначала проверяем документы СУПРУГА (они более специфичны)
        spouse_doc_types = ["паспорт_супруга", "инн_супруга", "снилс_супруга"]
        for doc_type in spouse_doc_types:
            if doc_type in DocumentProcessor.DOCUMENT_TYPES:
                config = DocumentProcessor.DOCUMENT_TYPES[doc_type]
                for keyword in config.get("keywords", []):
                    if keyword in filename_lower:
                        return doc_type, config["prompt"]
        
        # ПРИОРИТЕТ 2: Потом проверяем обычные документы ДОЛЖНИКА
        for doc_type, config in DocumentProcessor.DOCUMENT_TYPES.items():
            # Пропускаем документы супруга, они уже проверены
            if doc_type in spouse_doc_types:
                continue
            for keyword in config.get("keywords", []):
                if keyword in filename_lower:
                    return doc_type, config["prompt"]

        # Если не нашли по имени и есть текст - проверяем по содержимому
        if first_page_text:
            text_lower = first_page_text.lower()

            # Постановление пристава - высокий приоритет
            if any(kw in text_lower for kw in ["судебный пристав", "фссп", "исполнительное производство", "исполнительном производстве", "судебного пристава-исполнителя"]):
                config = DocumentProcessor.DOCUMENT_TYPES.get("постановление_пристава", {})
                return "постановление_пристава", config.get("prompt", "")

            # Договор поручительства
            if "поручител" in text_lower and "договор" in text_lower:
                # Это обычный договор, обрабатываем как общий с контекстом о поручительстве
                return "общий", """Договор поручительства.

Найди:
- Номер договора и дату
- Поручитель (кто даёт поручительство): ФИО
- Должник (за кого поручаются): ФИО
- Кредитор (в чью пользу поручительство): название организации
- Сумма обязательства
- Срок действия поручительства

JSON:
{
    "Тип": "Договор поручительства",
    "Номер": "...",
    "Дата": "ДД.ММ.ГГГГ",
    "Поручитель": "...",
    "Должник": "...",
    "Кредитор": "...",
    "Сумма": "...",
    "Срок": "..."
}
"""

            # ЕГРН выписка
            if "единый государственный реестр недвижимости" in text_lower or "кадастровый номер" in text_lower:
                if "отсутствуют сведения" in text_lower or "не найдено" in text_lower:
                    config = DocumentProcessor.DOCUMENT_TYPES.get("егрн_уведомление", {})
                    return "егрн_уведомление", config.get("prompt", "")
                else:
                    config = DocumentProcessor.DOCUMENT_TYPES.get("егрн_выписка", {})
                    return "егрн_выписка", config.get("prompt", "")

            # БКИ/НБКИ/ОКБ отчёты - проверяем по специфичным словам
            if "нбки" in text_lower or "национальное бюро кредитных историй" in text_lower:
                config = DocumentProcessor.DOCUMENT_TYPES.get("отчет_нбки", {})
                return "отчет_нбки", config.get("prompt", "")
            
            if "кредитная история" in text_lower or "скоринг" in text_lower or "бки" in text_lower:
                config = DocumentProcessor.DOCUMENT_TYPES.get("отчет_бки", {})
                return "отчет_бки", config.get("prompt", "")

            # Налоговое уведомление
            if "налоговое уведомление" in text_lower or ("всего к уплате" in text_lower and "фнс" in text_lower):
                config = DocumentProcessor.DOCUMENT_TYPES.get("налоговое_уведомление", {})
                return "налоговое_уведомление", config.get("prompt", "")

            # ГИБДД - заявление или справка (расширенная проверка)
            gibdd_keywords = ["гибдд", "гаи", "мрэо", "госавтоинспекция", "государственная инспекция безопасности дорожного движения"]
            transport_keywords = ["транспорт", "зарегистрирован", "заявление", "автомобил", "тс", "транспортн", "регистрац", "птс", "стс", "справка"]
            
            has_gibdd = any(kw in text_lower for kw in gibdd_keywords)
            has_transport = any(kw in text_lower for kw in transport_keywords)
            
            if has_gibdd or (has_transport and any(kw in filename_lower for kw in ["гибдд", "транспорт", "справка"])):
                config = DocumentProcessor.DOCUMENT_TYPES.get("гибдд", {})
                return "гибдд", config.get("prompt", "")

        # По умолчанию - общий тип
        return "общий", DocumentProcessor.DOCUMENT_TYPES.get("общий", {}).get(
            "prompt", "Проанализируй документ и верни JSON"
        )

    @staticmethod
    def clean_json_response(text: str) -> str:
        text = text.strip()
        if text.startswith("```json"):
            text = text[7:]
        elif text.startswith("```"):
            text = text[3:]
        if text.endswith("```"):
            text = text[:-3]
        return text.strip()

    @staticmethod
    def encode_image_to_base64(image_path: str) -> str:
        """Encode image to base64 for OpenAI API."""
        with open(image_path, "rb") as image_file:
            return base64.b64encode(image_file.read()).decode('utf-8')

    @staticmethod
    def parse_decimal(value: Optional[str]) -> Optional[Decimal]:
        if not value:
            return None
        cleaned = str(value)
        for token in ("\xa0", " ", "руб.", "руб", "р.", "р", "₽"):
            cleaned = cleaned.replace(token, "")
        cleaned = cleaned.replace(",", ".")
        allowed = "0123456789.-"
        normalized = "".join(ch for ch in cleaned if ch in allowed)
        if not normalized or normalized in {"-", ".", "-."}:
            return None
        try:
            return Decimal(normalized)
        except InvalidOperation:
            return None

    @staticmethod
    def format_decimal(value: Decimal) -> str:
        quantized = value.quantize(Decimal("0.01"))
        formatted = f"{quantized:,.2f}".replace(",", " ")
        return formatted.replace(".", ",")

    @staticmethod
    def format_count_with_word(count: int, singular: str, few: str, many: str) -> str:
        """Склоняет слово в зависимости от числа.
        
        Args:
            count: Число
            singular: Форма для 1 (счет)
            few: Форма для 2-4 (счета)
            many: Форма для 5+ и 0 (счетов)
            
        Returns:
            Строка вида "5 счетов", "1 счет", "3 счета"
        """
        if count % 10 == 1 and count % 100 != 11:
            return f"{count} {singular}"
        elif count % 10 in [2, 3, 4] and count % 100 not in [12, 13, 14]:
            return f"{count} {few}"
        else:
            return f"{count} {many}"

    @staticmethod
    def normalize_creditor_name(name: str) -> str:
        """Нормализует название кредитора (банка/МФО/МКК).
        
        Args:
            name: Исходное название
            
        Returns:
            Нормализованное название
        """
        if not name:
            return ""
        
        # 1. Убираем префикс "МФО: " и похожие
        result = name.strip()
        for prefix in ["МФО:", "Мфо:", "МФО :", "Мфо :", "Банк: ", "БАНК: ", "Банк :", "БАНК :"]:
            if result.startswith(prefix):
                result = result[len(prefix):].strip()
        
        # 2. Убираем историю переименований в скобках (ранее - ...)
        # Ищем последнюю открывающую скобку с текстом "ранее"
        import re
        result = re.sub(r'\s*\(ранее[^)]*\)\s*', ' ', result, flags=re.IGNORECASE)
        
        # 3. Нормализуем кавычки: '' "" → «»
        # СНАЧАЛА обрабатываем парные кавычки с помощью regex
        # Паттерн: ''текст'' → «текст»
        result = re.sub(r"''([^']+)''", r'«\1»', result)
        # Паттерн: ""текст"" → «текст»
        result = re.sub(r'""([^"]+)""', r'«\1»', result)
        # Паттерн: "текст" → «текст»
        result = re.sub(r'"([^"]+)"', r'«\1»', result)
        # Паттерн: 'текст' → «текст»
        result = re.sub(r"'([^']+)'", r'«\1»', result)
        
        # ПОТОМ заменяем умные кавычки (которые остались)
        result = result.replace('"', '«').replace('"', '»')  # Умные английские кавычки
        result = result.replace("'", '«').replace("'", '»')  # Умные одинарные кавычки
        
        # Разворачиваем неправильно развернутые кавычки ««текст»» → «текст»
        result = result.replace('««', '«').replace('»»', '»')
        
        # 4. Нормализуем аббревиатуры (МКК/МФК в верхний регистр) ПЕРЕД перестановкой структуры
        result = re.sub(r'\b(мкк|мфк|мфо|ооо|пао|ао)\b', lambda m: m.group(1).upper(), result, flags=re.IGNORECASE)
        
        # 5. Нормализуем структуру: ООО «Да-кредит МКК» → ООО МКК «Да-кредит»
        # Паттерн: ООО «[название] МКК/МФК» → ООО МКК/МФК «[название]»
        patterns = [
            # МКК/МФК в конце названия в кавычках
            (r'ООО\s+«([^»]+?)\s+(МКК|МФК|МФО)»', r'ООО \2 «\1»'),
            # МКК/МФК в начале названия в кавычках: ООО «МКК Название» → ООО МКК «Название»
            (r'ООО\s+«(МКК|МФК|МФО)\s+([^»]+)»', r'ООО \1 «\2»'),
            (r'Общество с ограниченной ответственностью\s+«([^»]+?)\s+(МКК|МФК|МФО)»', r'ООО \2 «\1»'),
            (r'ООО\s+([^\s«]+)\s+(МКК|МФК|МФО)', r'ООО \2 «\1»'),  # Без кавычек
        ]
        
        for pattern, replacement in patterns:
            result = re.sub(pattern, replacement, result, flags=re.IGNORECASE)
        
        # 6. Убираем лишние пробелы
        result = ' '.join(result.split())
        
        return result.strip()

    @staticmethod
    def extract_search_keywords(name: str) -> list:
        """Извлекает ключевые слова из названия для поиска в реестрах.
        
        Args:
            name: Название организации
            
        Returns:
            Список ключевых слов
        """
        import re
        
        # Убираем организационно-правовые формы и типы
        clean_name = name
        for prefix in ['ПАО', 'ОАО', 'ЗАО', 'АО', 'ООО', 'МКК', 'МФК', 'МФО', 
                       'Публичное акционерное общество', 'Акционерное общество',
                       'Общество с ограниченной ответственностью',
                       'Микрокредитная компания', 'Микрофинансовая компания',
                       'Микрофинансовая организация']:
            clean_name = re.sub(r'\b' + re.escape(prefix) + r'\b', '', clean_name, flags=re.IGNORECASE)
        
        # Убираем кавычки
        clean_name = clean_name.replace('«', '').replace('»', '').replace('"', '').replace("'", '')
        
        # Разбиваем на слова и берём значимые (длиннее 2 символов)
        words = [w.strip().lower() for w in clean_name.split() if len(w.strip()) > 2]
        
        return words

    @staticmethod
    def get_bank_address(bank_name: str) -> str:
        """Возвращает юридический адрес банка/МФО из реестров ЦБ РФ.

        Args:
            bank_name: Название банка/МФО (нормализованное или каноническое)

        Returns:
            Полный адрес из реестра или фоллбэк из словаря
        """
        # Извлекаем ключевые слова для поиска
        keywords = DocumentProcessor.extract_search_keywords(bank_name)
        
        # Определяем тип организации по названию
        name_upper = bank_name.upper()
        is_mfo = any(marker in name_upper for marker in ["МКК", "МФК", "МФО", "МИКРОКРЕДИТНАЯ", "МИКРОФИНАНСОВАЯ"])
        is_bank = any(marker in name_upper for marker in ["БАНК", "ПАО", "АО"])
        
        # Функция поиска в реестре
        def search_in_registry(registry, keywords):
            if not registry or not keywords:
                return None
            for key, data in registry.items():
                name_lower = data.get("название", "").lower()
                matches = sum(1 for kw in keywords if kw in name_lower)
                if matches >= len(keywords) * 0.7:  # 70% порог
                    address = data.get("адрес", "")
                    if address:
                        return address
            return None
        
        # Приоритет 1: Если это МФО/МКК - сначала ищем в MFO_REGISTRY
        if is_mfo and not is_bank:
            address = search_in_registry(DocumentProcessor.MFO_REGISTRY, keywords)
            if address:
                return address
            # Если не нашли - пробуем в BANK_REGISTRY
            address = search_in_registry(DocumentProcessor.BANK_REGISTRY, keywords)
            if address:
                return address
        
        # Приоритет 2: Если это банк - сначала ищем в BANK_REGISTRY
        elif is_bank:
            address = search_in_registry(DocumentProcessor.BANK_REGISTRY, keywords)
            if address:
                return address
            # Если не нашли - пробуем в MFO_REGISTRY
            address = search_in_registry(DocumentProcessor.MFO_REGISTRY, keywords)
            if address:
                return address
        
        # Приоритет 3: Если тип неизвестен - ищем в обоих реестрах
        else:
            address = search_in_registry(DocumentProcessor.MFO_REGISTRY, keywords)
            if address:
                return address
            address = search_in_registry(DocumentProcessor.BANK_REGISTRY, keywords)
            if address:
                return address
        
        # 3. FALLBACK: словарь адресов банков и МФО (данные на 03.11.2025)
        BANK_ADDRESSES = {
            # Крупнейшие банки
            "СБЕРБАНК": "117312, г. Москва, ул. Вавилова, д. 19",
            "СБЕРБАНК РОССИИ": "117312, г. Москва, ул. Вавилова, д. 19",
            "РОССИИ": "117312, г. Москва, ул. Вавилова, д. 19",  # Для "Сбербанк России"
            "ВТБ": "191144, г. Санкт-Петербург, Дегтярный переулок, д. 11, лит. А",
            "АЛЬФА": "107078, г. Москва, ул. Каланчёвская, д. 27",
            "ТИНЬКОФФ": "127287, г. Москва, 2-я Хуторская ул., д. 38А, стр. 26",
            "МТС": "115432, г. Москва, проспект Андропова, д. 18, корп. 1",
            "ГАЗПРОМБАНК": "117420, г. Москва, ул. Наметкина, д. 10",
            "РОССЕЛЬХОЗБАНК": "119034, г. Москва, Гагаринский пер., д. 3",
            "СОВКОМБАНК": "156000, Костромская область, г. Кострома, проспект Текстильщиков, д. 46",
            "ОТКРЫТИЕ": "115114, г. Москва, ул. Летниковская, д. 2, стр. 4",
            "ПОЧТА": "107061, г. Москва, Преображенская пл., д. 8",
            "УРАЛСИБ": "119048, г. Москва, ул. Ефремова, д. 8",
            "ПРОМСВЯЗЬБАНК": "109052, г. Москва, ул. Смирновская, д. 10, стр. 22",
            "ОТП": "125171, г. Москва, Ленинградское ш., д. 16А, стр. 2",
            "РЕНЕССАНС": "115114, г. Москва, ул. Кожевническая, д. 14",
            "РУССКИЙ СТАНДАРТ": "105187, г. Москва, ул. Ткацкая, д. 36",
            "РАЙФФАЙЗЕНБАНК": "119002, г. Москва, Смоленская-Сенная пл., д. 28",
            "РОСБАНК": "107078, г. Москва, ул. Маши Порываевой, д. 34",
            "ХОУМ КРЕДИТ": "125040, г. Москва, 3-я ул. Ямского Поля, д. 44",
            "РУСФИНАНС": "127015, г. Москва, ул. Новодмитровская Б., д. 14, стр. 1",

            # Московские банки
            "МОСКОВСКИЙ КРЕДИТНЫЙ": "107045, г. Москва, Луков пер., д. 2, стр. 1",
            "МКБ": "107045, г. Москва, Луков пер., д. 2, стр. 1",
            "АБСОЛЮТ": "127051, г. Москва, Цветной б-р, д. 18",
            "АВАНГАРД": "119180, г. Москва, ул. Большая Якиманка, д. 1",
            "ЛОКО": "125167, г. Москва, Ленинградский проспект, д. 39, стр. 80",
            "ТРАСТ": "121151, г. Москва, ул. Можайский Вал, д. 8",
            "МЕТАЛЛИНВЕСТБАНК": "119180, г. Москва, ул. Большая Полянка, д. 47, стр. 2",
            "НОВИКОМБАНК": "119180, г. Москва, ул. Большая Полянка, д. 50/1, стр. 1",
            "ЗЕНИТ": "129090, г. Москва, ул. Троицкая, д. 17, стр. 1",
            "СДМ": "125424, г. Москва, Волоколамское ш., д. 73",
            "ЮНИКРЕДИТ": "119034, г. Москва, Пречистенская наб., д. 9",
            "СИТИБАНК": "125047, г. Москва, ул. Гашека, д. 8–10, стр. 1",
            "ИНТЕЗА": "101000, г. Москва, Петроверигский пер., д. 2",
            "РОСЭКСИМБАНК": "123610, г. Москва, Краснопресненская наб., д. 12",
            "ФИНАМ": "127006, г. Москва, Настасьинский пер., д. 7, стр. 2",
            "ЯНДЕКС": "115035, г. Москва, ул. Садовническая, д. 82, стр. 2",

            # Санкт-Петербург
            "САНКТ ПЕТЕРБУРГ": "195112, г. Санкт-Петербург, Малоохтинский пр., д. 64, лит. А",
            "АЛЕКСАНДРОВСКИЙ": "191119, г. Санкт-Петербург, Загородный пр., д. 46, лит. Б, корп. 2",
            "ПСКБ": "191123, г. Санкт-Петербург, ул. Шпалерная, д. 42, лит. А",
            "БАЛТИНВЕСТБАНК": "197101, г. Санкт-Петербург, ул. Дивенская, д. 1, лит. А",

            # Региональные банки
            "КУБАНЬ КРЕДИТ": "350000, Краснодарский край, г. Краснодар, ул. Орджоникидзе, д. 46",
            "КУБАНЬ": "350000, Краснодарский край, г. Краснодар, ул. Орджоникидзе, д. 46",
            "ПРИМСОЦБАНК": "690106, Приморский край, г. Владивосток, Партизанский проспект, д. 44",
            "ПРИМОРЬЕ": "690091, Приморский край, г. Владивосток, ул. Светланская, д. 47",
            "ДАЛЬНЕВОСТОЧНЫЙ": "690990, Приморский край, г. Владивосток, ул. Верхнепортовая, д. 27а",

            # МФО/МФК
            "ЗАЙМЕР": "г. Москва",
            "ZAIMER": "г. Москва",
            "ВЭББАНКИР": "125627, г. Москва, ул. Соколово-Мещерская, д. 29, оф. 308",
            "ВЕББАНКИР": "125627, г. Москва, ул. Соколово-Мещерская, д. 29, оф. 308",
            "ВЭБ БАНКИР": "125627, г. Москва, ул. Соколово-Мещерская, д. 29, оф. 308",
            "WEBBANKIR": "125627, г. Москва, ул. Соколово-Мещерская, д. 29, оф. 308",
            "ТУРБОЗАЙМ": "г. Москва",
            "TURBOZAIM": "г. Москва",
            "МАНИ МЕН": "121096, г. Москва, ул. Василисы Кожиной, д. 1, оф. Д13",
            "МАНИМЕН": "121096, г. Москва, ул. Василисы Кожиной, д. 1, оф. Д13",
            "MONEYMAN": "121096, г. Москва, ул. Василисы Кожиной, д. 1, оф. Д13",
            "МИГ КРЕДИТ": "127015, г. Москва, вн. тер. г. мун. округ Бутырский, ул. Большая Новодмитровская, д. 23, стр. 3",
            "МИГКРЕДИТ": "127015, г. Москва, вн. тер. г. мун. округ Бутырский, ул. Большая Новодмитровская, д. 23, стр. 3",
            "MIG KREDIT": "127015, г. Москва, вн. тер. г. мун. округ Бутырский, ул. Большая Новодмитровская, д. 23, стр. 3",
            "ЛАЙМ": "630102, Новосибирская область, г. Новосибирск, ул. Кирова, д. 48, оф. 1401",
            "LIME": "630102, Новосибирская область, г. Новосибирск, ул. Кирова, д. 48, оф. 1401",
            "БЫСТРОДЕНЬГИ": "121087, г. Москва, вн. тер. г. мун. округ Филёвский парк, ул. Барклая, д. 6, стр. 5",
            "БЫСТРО ДЕНЬГИ": "121087, г. Москва, вн. тер. г. мун. округ Филёвский парк, ул. Барклая, д. 6, стр. 5",
            "BISTRODENGI": "121087, г. Москва, вн. тер. г. мун. округ Филёвский парк, ул. Барклая, д. 6, стр. 5",
            "СРОЧНОДЕНЬГИ": "603022, Нижегородская область, г. Нижний Новгород, ул. Тимирязева, д. 15, корп. 2, помещ. П406",
            "СРОЧНО ДЕНЬГИ": "603022, Нижегородская область, г. Нижний Новгород, ул. Тимирязева, д. 15, корп. 2, помещ. П406",
            "ЕКАПУСТА": "г. Москва",
            "Е КАПУСТА": "г. Москва",
            "EKAPUSTA": "г. Москва",
            "МИКРОЗАЙМ": "г. Москва",
            "МИКРО ЗАЙМ": "г. Москва",
            "ЗАЙМОГРАД": "г. Москва",
            "РУСИНТЕРФИНАНС": "630055, Новосибирская область, г. Новосибирск, ул. Гнесиных, д. 10/1, оф. 202",
            "КОРОНА": "630559, Новосибирская область, р.п. Кольцово, ул. Технопарковая, стр. 1",
            "СТРАНА ЭКСПРЕСС": "630559, Новосибирская область, р.п. Кольцово, ул. Технопарковая, стр. 1",
            "А ДЕНЬГИ": "107078, г. Москва, ул. Маши Порываевой, д. 7, стр. А, этаж 8, помещ. 5–6Б, ком. 805–806",
            "ДЗП ЕДИНЫЙ": "197374, г. Санкт-Петербург, муниципальный округ № 65, ул. Мебельная, д. 12, корп. 1, лит. А, помещ. 53-Н, ком. 428",
            "АКАДЕМИЧЕСКАЯ": "630007, Новосибирская область, г. Новосибирск, ул. Коммунистическая, д. 50",
        }

        # Нормализуем название банка для поиска
        search_name = bank_name.upper().strip()

        # Убираем ОПФ и лишние символы (только целые слова в начале/конце)
        import re
        for opf in ["ПАО", "АО", "ООО", "ОАО", "МФК", "МКК", "КБ"]:
            # Убираем ОПФ только в начале или конце (целое слово)
            search_name = re.sub(r'\b' + opf + r'\b', ' ', search_name)

        search_name = search_name.replace("«", "").replace("»", "").replace('"', "")
        search_name = search_name.replace("-", " ")
        while "  " in search_name:
            search_name = search_name.replace("  ", " ")
        search_name = search_name.strip()

        # Ищем точное совпадение
        if search_name in BANK_ADDRESSES:
            return BANK_ADDRESSES[search_name]

        # Ищем частичное совпадение (самое длинное)
        matches = []
        for key, addr in BANK_ADDRESSES.items():
            # Проверяем наличие ключевых слов из key в search_name
            key_words = set(key.split())
            search_words = set(search_name.split())

            # Если все слова из key есть в search_name (или наоборот)
            if key_words.issubset(search_words) or search_words.issubset(key_words):
                matches.append((len(key), addr))
            # Или если одна строка содержит другую
            elif key in search_name or search_name in key:
                matches.append((len(key), addr))

        if matches:
            matches.sort(reverse=True)
            return matches[0][1]

        # Если не нашли - возвращаем "Москва" для банков, пустую строку для остальных
        if any(word in bank_name.upper() for word in ["БАНК", "МФК", "МКК", "МФО"]):
            return "г. Москва"

        return ""

    @staticmethod
    def get_bank_inn(bank_name: str) -> str:
        """Возвращает ИНН банка/МФО из реестров ЦБ РФ.

        Args:
            bank_name: Название банка/МФО (нормализованное или каноническое)

        Returns:
            ИНН из реестра или фоллбэк из словаря
        """
        # Извлекаем ключевые слова для поиска
        keywords = DocumentProcessor.extract_search_keywords(bank_name)
        
        # Определяем тип организации по названию
        name_upper = bank_name.upper()
        is_mfo = any(marker in name_upper for marker in ["МКК", "МФК", "МФО", "МИКРОКРЕДИТНАЯ", "МИКРОФИНАНСОВАЯ"])
        is_bank = any(marker in name_upper for marker in ["БАНК", "ПАО", "АО"])
        
        # Функция поиска ИНН в реестре МФО (ключ = ИНН)
        def search_inn_in_mfo(keywords):
            if not DocumentProcessor.MFO_REGISTRY or not keywords:
                return None
            for inn, mfo_data in DocumentProcessor.MFO_REGISTRY.items():
                mfo_name_lower = mfo_data.get("название", "").lower()
                matches = sum(1 for kw in keywords if kw in mfo_name_lower)
                if matches >= len(keywords) * 0.7:  # 70% порог
                    return inn  # Ключ словаря - это ИНН!
            return None
        
        # Функция поиска ИНН в реестре банков (поле "инн")
        def search_inn_in_bank(keywords):
            if not DocumentProcessor.BANK_REGISTRY or not keywords:
                return None
            for ogrn, bank_data in DocumentProcessor.BANK_REGISTRY.items():
                bank_name_lower = bank_data.get("название", "").lower()
                matches = sum(1 for kw in keywords if kw in bank_name_lower)
                if matches >= len(keywords) * 0.7:  # 70% порог
                    inn = bank_data.get("инн", "")
                    if inn:
                        return inn
            return None
        
        # Приоритет 1: Если это МФО/МКК - сначала ищем в MFO_REGISTRY
        if is_mfo and not is_bank:
            inn = search_inn_in_mfo(keywords)
            if inn:
                return inn
            inn = search_inn_in_bank(keywords)
            if inn:
                return inn
        
        # Приоритет 2: Если это банк - сначала ищем в BANK_REGISTRY
        elif is_bank:
            inn = search_inn_in_bank(keywords)
            if inn:
                return inn
            inn = search_inn_in_mfo(keywords)
            if inn:
                return inn
        
        # Приоритет 3: Если тип неизвестен - ищем в обоих реестрах
        else:
            inn = search_inn_in_mfo(keywords)
            if inn:
                return inn
            inn = search_inn_in_bank(keywords)
            if inn:
                return inn
        
        # 2. FALLBACK: словарь ИНН банков (данные на 03.11.2025)
        BANK_INN = {
            # Крупнейшие банки
            "СБЕРБАНК": "7707083893",
            "СБЕРБАНК РОССИИ": "7707083893",
            "РОССИИ": "7707083893",
            "ВТБ": "7702070139",
            "АЛЬФА": "7728168971",
            "ТИНЬКОФФ": "7710140679",
            "Т-БАНК": "7710140679",  # Тинькофф переименован в Т-Банк
            "МТС": "7702045051",
            "ГАЗПРОМБАНК": "7744001497",
            "РОССЕЛЬХОЗБАНК": "7725114488",
            "СОВКОМБАНК": "4401116480",
            "ОТКРЫТИЕ": "7706092528",
            "ПОЧТА": "3232005484",
            "УРАЛСИБ": "0274062111",
            "ПРОМСВЯЗЬБАНК": "7744000912",
            "ОТП": "7708001614",
            "РЕНЕССАНС": "7744000126",
            "РУССКИЙ СТАНДАРТ": "7738177339",
            "РАЙФФАЙЗЕНБАНК": "7744000302",
            "РОСБАНК": "7272101820",
            "ХОУМ КРЕДИТ": "7710140679",  # Хоум Кредит теперь Т-Банк (бывший Тинькофф)
            "Т БАНК": "7710140679",
            "T BANK": "7710140679",
            "TBANK": "7710140679",
            "РУСФИНАНС": "5047102587",
            "МОСКОВСКИЙ КРЕДИТНЫЙ": "7734202860",
            "МКБ": "7734202860",
            "АБСОЛЮТ": "7736046991",
            "АВАНГАРД": "7729076543",
            "ЛОКО": "7750003943",
            "ТРАСТ": "7831001567",
            "ЗЕНИТ": "7729405872",
            "ЮНИКРЕДИТ": "7710030411",
            "ЧЕЛЯБИНВЕСТБАНК": "7452017275",
            "УРАЛЬСКИЙ БАНК РЕКОНСТРУКЦИИ": "6608000242",
            "УБРиР": "6608000242",
        }

        # Нормализуем название банка для поиска
        search_name = bank_name.upper().strip()

        # Убираем ОПФ и лишние символы
        import re
        for opf in ["ПАО", "АО", "ООО", "ОАО", "МФК", "МКК", "КБ"]:
            search_name = re.sub(r'\b' + opf + r'\b', ' ', search_name)

        search_name = search_name.replace("«", "").replace("»", "").replace('"', "")
        search_name = search_name.replace("-", " ")
        while "  " in search_name:
            search_name = search_name.replace("  ", " ")
        search_name = search_name.strip()

        # Ищем точное совпадение
        if search_name in BANK_INN:
            return BANK_INN[search_name]

        # Ищем частичное совпадение
        for key, inn in BANK_INN.items():
            key_words = set(key.split())
            search_words = set(search_name.split())

            if key_words.issubset(search_words) or search_words.issubset(key_words):
                return inn
            elif key in search_name or search_name in key:
                return inn

        return ""

    @staticmethod
    def normalize_bank_name(name: str) -> tuple[str, str]:
        """Нормализует название банка для объединения дубликатов.

        Возвращает кортеж: (нормализованное_название, каноническое_название)
        - нормализованное_название - для сравнения и группировки
        - каноническое_название - правильный формат для отображения

        Примеры:
            "МТС-БАНК ПАО" -> ("МТС БАНК", "ПАО «МТС-Банк»")
            "ПАО «МТС-Банк»" -> ("МТС БАНК", "ПАО «МТС-Банк»")
            "Сбербанк России" -> ("СБЕРБАНК", "ПАО Сбербанк")
        """
        if not name:
            return ("", "")

        original = name.strip()
        
        # СНАЧАЛА применяем нормализацию МФО/МКК (убираем "МФО:", историю, кавычки)
        canonical_name = DocumentProcessor.normalize_creditor_name(original)

        # Словарь канонических названий известных банков/МФО
        CANONICAL_NAMES = {
            "СБЕРБАНК": "ПАО «Сбербанк»",
            "СБЕР": "ПАО «Сбербанк»",
            "СБЕР РОССИИ": "ПАО «Сбербанк»",
            "РОССИИ": "ПАО «Сбербанк»",  # Для "Сбербанк России" после удаления "БАНК"
            "ВТБ": "ПАО «ВТБ»",
            "АЛЬФА БАНК": "АО «Альфа-Банк»",
            "АЛЬФА": "АО «Альфа-Банк»",
            "ТИНЬКОФФ": "АО «Тинькофф Банк»",
            "ТИНЬКОФФ БАНК": "АО «Тинькофф Банк»",
            "ТИНКОВ": "АО «Тинькофф Банк»",
            "РОССЕЛЬХОЗБАНК": "АО «Россельхозбанк»",
            "РОССЕЛЬХОЗ": "АО «Россельхозбанк»",
            "ГАЗПРОМБАНК": "АО «ГПБ»",
            "ГАЗПРОМ": "АО «ГПБ»",
            "МТС БАНК": "ПАО «МТС-Банк»",
            "МТС": "ПАО «МТС-Банк»",
            "РАЙФФАЙЗЕНБАНК": "АО «Райффайзенбанк»",
            "РАЙФФАЙЗЕН": "АО «Райффайзенбанк»",
            "РОСБАНК": "ПАО «РОСБАНК»",
            "РОС": "ПАО «РОСБАНК»",
            "ХОУМ КРЕДИТ": "АО «Т-Банк»",  # Хоум Кредит продан Тинькофф и переименован в Т-Банк
            "ХОУМ КРЕДИТ ЭНД ФИНАНС": "АО «Т-Банк»",
            "HOME CREDIT": "АО «Т-Банк»",
            "Т БАНК": "АО «Т-Банк»",
            "T BANK": "АО «Т-Банк»",
            "TBANK": "АО «Т-Банк»",
            "РУСФИНАНС БАНК": "ООО КБ «Русфинанс Банк»",
            "РУСФИНАНС": "ООО КБ «Русфинанс Банк»",
            "РУСИНТЕРФИНАНС": "ООО МКК «Русинтерфинанс»",
            "РУСИНЕРФИНАНС": "ООО МКК «Русинтерфинанс»",
            "РУС ИНТЕР ФИНАНС": "ООО МКК «Русинтерфинанс»",
            "СОВКОМБАНК": "ПАО «Совкомбанк»",
            "СОВКОМ": "ПАО «Совкомбанк»",
            "ОТКРЫТИЕ": "ПАО Банк «ФК Открытие»",
            "ПОЧТА БАНК": "ПАО «Почта Банк»",
            "ПОЧТА": "ПАО «Почта Банк»",
            "УРАЛСИБ": "ПАО «БАНК УРАЛСИБ»",
            "УРАЛ СИБ": "ПАО «БАНК УРАЛСИБ»",
            "ПРОМСВЯЗЬБАНК": "ПАО «Промсвязьбанк»",
            "ПРОМСВЯЗЬ": "ПАО «Промсвязьбанк»",
            "ОТП БАНК": "АО «ОТП Банк»",
            "ОТП": "АО «ОТП Банк»",
            "РЕНЕССАНС КРЕДИТ": "ООО КБ «Ренессанс Кредит»",
            "РЕНЕССАНС": "ООО КБ «Ренессанс Кредит»",
            "РУССКИЙ СТАНДАРТ": "АО «Банк Русский Стандарт»",

            # МФО/МФК/МКК
            "ЗАЙМЕР": "ООО МФК «Займер»",
            "ЗАЙМ ЭР": "ООО МФК «Займер»",
            "ВЭББАНКИР": "ООО МКК «ВэбБанкир»",
            "ВЕББАНКИР": "ООО МКК «ВэбБанкир»",
            "ВЭЗББАНКИР": "ООО МКК «ВэбБанкир»",
            "ВЭЗБАНКИР": "ООО МКК «ВэбБанкир»",
            "ВЭБ ИР": "ООО МКК «ВэбБанкир»",
            "ВЭЗБ ИР": "ООО МКК «ВэбБанкир»",
            "WEBBANKIR": "ООО МКК «ВэбБанкир»",
            "ТУРБОЗАЙМ": "ООО МКК «ТурбоЗайм»",
            "ТУРБО ЗАЙМ": "ООО МКК «ТурбоЗайм»",
            "ТУРБО": "ООО МКК «ТурбоЗайм»",
            "TURBOZAIM": "ООО МКК «ТурбоЗайм»",
            "МОНЕЙМЕН": "ООО МФК «МаниМен»",
            "МАНИ МЕН": "ООО МФК «МаниМен»",
            "MONEYMAN": "ООО МФК «МаниМен»",
            "MONEY MAN": "ООО МФК «МаниМен»",
            "МИГКРЕДИТ": "ООО МФК «МигКредит»",
            "МИГ КРЕДИТ": "ООО МФК «МигКредит»",
            "МИГ": "ООО МФК «МигКредит»",
            "MIGCREDIT": "ООО МФК «МигКредит»",
            "MIGKREDIT": "ООО МФК «МигКредит»",
            "ДЕНЬГИ СРАЗУ": "ООО МКК «Деньги сразу»",
            "DENGISRAZY": "ООО МКК «Деньги сразу»",
            "DENGI SRAZY": "ООО МКК «Деньги сразу»",
            "ЕKAPУСТА": "ООО МКК «Екапуста»",
            "Е КАПУСТА": "ООО МКК «Екапуста»",
            "EKAPUSTA": "ООО МКК «Екапуста»",
            "E KAPUSTA": "ООО МКК «Екапуста»",
            "ЛАЙМ ЗАЙМ": "ООО МФК «Лайм-Займ»",
            "ЛАЙМ": "ООО МФК «Лайм-Займ»",
            "LIME ZAIM": "ООО МФК «Лайм-Займ»",
            "LIMEZAIM": "ООО МФК «Лайм-Займ»",
            "СРОЧНОДЕНЬГИ": "ООО МФК «СрочноДеньги»",
            "СРОЧНО ДЕНЬГИ": "ООО МФК «СрочноДеньги»",
            "SROCHNODENGІ": "ООО МФК «СрочноДеньги»",
            "БЫСТРОДЕНЬГИ": "ООО МКК «БыстроДеньги»",
            "БЫСТРО ДЕНЬГИ": "ООО МКК «БыстроДеньги»",
            "BISTRODENGI": "ООО МКК «БыстроДеньги»",
            "МИКРОЗАЙМ": "ООО МФК «МикроЗайм»",
            "МИКРО ЗАЙМ": "ООО МФК «МикроЗайм»",
            "MICROZAIM": "ООО МФК «МикроЗайм»",
            "ЗАЙМОГРАД": "ООО МКК «ЗаймоГрад»",
            "ZAIMO GRAD": "ООО МКК «ЗаймоГрад»",
            "ZAIMOGRAD": "ООО МКК «ЗаймоГрад»",
            "РУСИНТЕРФИНАНС": "ООО МКК «Русинтерфинанс»",
            "РУСИНТЕР ФИНАНС": "ООО МКК «Русинтерфинанс»",
            "RUSINTERFINANS": "ООО МКК «Русинтерфинанс»",
        }

        # Шаг 1: Убираем организационно-правовые формы и знаки (используем нормализованное название)
        normalized = canonical_name.upper()

        # Убираем кавычки всех типов
        normalized = normalized.replace('"', '').replace("'", '').replace('«', '').replace('»', '')

        # Убираем организационно-правовые формы
        opf_patterns = [
            "ПУБЛИЧНОЕ АКЦИОНЕРНОЕ ОБЩЕСТВО",
            "АКЦИОНЕРНОЕ ОБЩЕСТВО",
            "ОБЩЕСТВО С ОГРАНИЧЕННОЙ ОТВЕТСТВЕННОСТЬЮ",
            "КОММЕРЧЕСКИЙ БАНК",
            "МИКРОФИНАНСОВАЯ КОМПАНИЯ",
            "МИКРОКРЕДИТНАЯ КОМПАНИЯ",
            "МИКРОФИНАНСОВАЯ ОРГАНИЗАЦИЯ",
            "ПАО", "АО", "ООО", "ОАО", "ЗАО",
            "МФК", "МКК", "МФО",
            "КБ", "БАНК",
        ]

        for pattern in opf_patterns:
            normalized = normalized.replace(pattern, " ")

        # Убираем скобки и дефисы
        normalized = normalized.replace("(", " ").replace(")", " ")
        normalized = normalized.replace("-", " ")
        normalized = normalized.replace("  ", " ").replace("  ", " ")  # Двойная очистка
        normalized = normalized.strip()

        # Шаг 2: Ищем каноническое название
        canonical = CANONICAL_NAMES.get(normalized)

        # Если не нашли точное совпадение, ищем частичное
        if not canonical:
            # Сначала ищем полное вхождение нормализованного в ключи
            for key, value in CANONICAL_NAMES.items():
                if normalized == key:
                    canonical = value
                    break

            # Затем ищем частичное совпадение (приоритет длинным совпадениям)
            if not canonical:
                matches = []
                for key, value in CANONICAL_NAMES.items():
                    # Проверяем вхождение в обе стороны
                    # НО пропускаем слишком короткие ключи (менее 4 символов) для частичного совпадения
                    # чтобы "АЛЬФА" не совпала с "СФО АЛЬФА ФАБРИКА ПК 1"
                    if key in normalized and len(key) >= 4:
                        # Дополнительная проверка: если это короткое слово, убедимся что это отдельное слово
                        if len(key) < 6:
                            # Проверяем что это отдельное слово (окружено пробелами или краями)
                            words = normalized.split()
                            if key in words:
                                matches.append((len(key), key, value))
                        else:
                            matches.append((len(key), key, value))
                    elif normalized in key and len(normalized) >= 4:
                        matches.append((len(key), key, value))

                # Берем самое длинное совпадение
                if matches:
                    matches.sort(reverse=True)  # Сортируем по длине
                    _, normalized, canonical = matches[0]

        # Если не нашли в словаре, используем нормализованное название
        if not canonical:
            # Используем уже нормализованное название (с правильными кавычками и без префиксов)
            canonical = canonical_name

            # Если нормализованное название весь в CAPS, делаем красиво
            if canonical_name.isupper():
                # Извлекаем ОПФ из начала
                opf = ""
                rest = canonical_name
                for pattern in ["ПАО", "АО", "ООО", "ОАО"]:
                    if canonical_name.startswith(pattern + " "):
                        opf = pattern
                        rest = canonical_name[len(pattern):].strip()
                        break

                # Убираем кавычки
                rest = rest.replace('"', '').replace("'", '').replace('«', '').replace('»', '')

                # Делаем первую букву заглавной, остальные строчными
                rest_parts = rest.split()
                rest_formatted = ' '.join(
                    word if word in ["МТС", "ВТБ", "ОТП"] else word.capitalize() 
                    for word in rest_parts
                )

                # Собираем обратно
                if opf:
                    canonical = f'{opf} «{rest_formatted}»'
                else:
                    canonical = rest_formatted

        return (normalized, canonical)

    @staticmethod
    def select_first_entry(cache: Dict[str, List[Dict[str, Any]]], key: str) -> Dict[str, Any]:
        for item in cache.get(key, []):
            if isinstance(item, dict):
                return item
        return {}

    @staticmethod
    def extract_employers(records: Dict[str, Any]) -> str:
        """Извлекает текущее место работы из трудовой книжки."""
        if not records:
            return "Должник в настоящее время не работает"
        
        # Проверяем поле Текущая_работа из GPT
        current_work = records.get("Текущая_работа")
        if current_work and current_work != "Нет":
            return f"Должник работает в {current_work}"
        
        # Если нет - проверяем последнюю запись
        entries = records.get("Записи", []) or []
        if not entries:
            return "Должник в настоящее время не работает"
        
        # Последняя запись (записи отсортированы по дате)
        last_entry = entries[-1]
        if last_entry and last_entry.get("Событие") != "Увольнение":
            employer = last_entry.get("Работодатель", "")
            position = last_entry.get("Должность", "")
            if employer:
                workplace = f"{employer}, {position}" if position else employer
                return f"Должник работает в {workplace}"
        
        return "Должник в настоящее время не работает"

    @staticmethod
    def extract_current_job(records: Dict[str, Any]) -> str:
        """Извлекает только текущее место работы из трудовой книжки.
        
        Returns:
            Текущее место работы или "Нет" если человек не работает
        """
        if not records:
            return "Нет"
        
        # Проверяем поле Текущая_работа из GPT
        current_work = records.get("Текущая_работа")
        if current_work:
            return current_work
        
        # Если нет - проверяем последнюю запись
        entries = records.get("Записи", []) or []
        if not entries:
            return "Нет"
        
        # Последняя запись (записи отсортированы по дате)
        last_entry = entries[-1]
        if last_entry and last_entry.get("Событие") != "Увольнение":
            employer = last_entry.get("Работодатель", "")
            position = last_entry.get("Должность", "")
            if employer:
                return f"{employer}, {position}" if position else employer
        
        return "Нет"

    @staticmethod
    def format_interested_party(passport_spouse: Dict[str, Any], inn_spouse: Dict[str, Any], snils_spouse: Dict[str, Any]) -> str:
        """Форматирует информацию о супруге (заинтересованном лице).
        
        Args:
            passport_spouse: Данные паспорта супруга
            inn_spouse: Данные ИНН супруга
            snils_spouse: Данные СНИЛС супруга
            
        Returns:
            Отформатированный текст с данными супруга или пустая строка
        """
        if not passport_spouse:
            return ""
        
        # ФИО
        fio = passport_spouse.get("ФИО", "")
        if not fio:
            return ""
        
        # Дата и место рождения
        birth_date = passport_spouse.get("Дата_рождения", "")
        birth_place = passport_spouse.get("Место_рождения", "")
        
        birth_info = ""
        if birth_date:
            birth_info = f"{birth_date} г.р."
            if birth_place:
                birth_info += f", {birth_place}"
        elif birth_place:
            birth_info = birth_place
        
        # Адрес регистрации
        address = passport_spouse.get("Прописка", "")
        
        # Формируем текст
        lines = [f"Заинтересованное лицо:\n{fio}"]
        
        if birth_info:
            lines.append(f"Дата и место рождения: {birth_info};")
        
        if address:
            lines.append(f"Адрес проживания: {address};")
        
        return "\n".join(lines)

    @staticmethod
    def get_yekaterinburg_date() -> Dict[str, str]:
        """Получает текущую дату по Екатеринбургскому времени (Asia/Yekaterinburg, UTC+5).
        
        Returns:
            Словарь с ключами:
            - АДень: день (например, "12")
            - АМесяц: месяц на русском с заглавной (например, "Декабря")
            - АГод: полный год (например, "2025")
            - ААГод: последние 2 цифры года (например, "25")
        """
        # Получаем текущую дату по Екатеринбургскому времени
        yekaterinburg_tz = ZoneInfo("Asia/Yekaterinburg")
        now = datetime.now(yekaterinburg_tz)
        
        # Названия месяцев в родительном падеже (кого? чего?)
        months_genitive = {
            1: "Января",
            2: "Февраля",
            3: "Марта",
            4: "Апреля",
            5: "Мая",
            6: "Июня",
            7: "Июля",
            8: "Августа",
            9: "Сентября",
            10: "Октября",
            11: "Ноября",
            12: "Декабря"
        }
        
        return {
            "АДень": str(now.day),
            "АМесяц": months_genitive[now.month],
            "АГод": str(now.year),
            "ААГод": str(now.year)[-2:]  # Последние 2 цифры
        }

    @staticmethod
    def calculate_bank_accounts(data_list: List[Dict[str, Any]]) -> Optional[int]:
        for data in data_list:
            accounts = data.get("Счета") or []
            if isinstance(accounts, list):
                return len(accounts)
        return None

    @staticmethod
    def describe_real_estate(data_list: List[Dict[str, Any]]) -> str:
        descriptions: List[str] = []
        for data in data_list:
            obj = data.get("Объект") or {}
            parts: List[str] = []
            vid = obj.get("Вид")
            address = obj.get("Адрес")
            area = obj.get("Площадь")
            if vid:
                parts.append(str(vid))
            if address:
                parts.append(f"адрес: {address}")
            if area:
                parts.append(f"площадь {area}")
            if parts:
                descriptions.append(", ".join(parts))
        return "; ".join(descriptions)

    @staticmethod
    def determine_children_status(children: Optional[List[Dict[str, Any]]], data_map: Dict[str, List[Dict[str, Any]]] = None) -> str:
        """Определяет наличие несовершеннолетних детей.
        
        Args:
            children: список детей из паспорта
            data_map: словарь всех документов (для проверки свидетельств о рождении)
        """
        today = date.today()
        minors: List[str] = []
        
        # Собираем детей из паспорта
        if children:
            for child in children:
                if not isinstance(child, dict):
                    continue
                name = child.get("ФИО") or ""
                dob_str = child.get("Дата_рождения")
                if not dob_str:
                    continue
                try:
                    dob = datetime.strptime(dob_str, "%d.%m.%Y").date()
                    age_years = (today - dob).days / 365.25
                    if age_years < 18:
                        entry = f"{name} ({dob_str})" if name else dob_str
                        minors.append(entry.strip())
                except ValueError:
                    continue
        
        # Дополнительно проверяем свидетельства о рождении
        if data_map:
            birth_certificates = data_map.get("свидетельство_о_рождении", [])
            for cert in birth_certificates:
                if not isinstance(cert, dict):
                    continue
                name = cert.get("Ребенок_ФИО") or ""
                dob_str = cert.get("Дата_рождения")
                if not dob_str:
                    continue
                try:
                    dob = datetime.strptime(dob_str, "%d.%m.%Y").date()
                    age_years = (today - dob).days / 365.25
                    if age_years < 18:
                        entry = f"{name} ({dob_str})" if name else dob_str
                        # Проверяем, что такого ребенка еще нет в списке
                        if entry.strip() not in minors:
                            minors.append(entry.strip())
                except ValueError:
                    continue
        
        if minors:
            return "; ".join(minors)
        return "нет"

    @staticmethod
    def get_marital_status_key(passport: Dict[str, Any], data_map: Dict[str, List[Dict[str, Any]]] = None) -> str:
        """Формирует значение для ключа {{Женатзамужем}}.
        
        Args:
            passport: данные паспорта должника
            data_map: словарь всех документов (для проверки свидетельств о браке)
            
        Returns:
            Строка: "женат, супруга ФИО ДД.ММ.ГГГГ г.р." или "замужем, супруг ФИО ДД.ММ.ГГГГ г.р." или "Нет"
        """
        if not passport:
            return "Нет"
        
        # Определяем пол должника
        gender = (passport.get("Пол") or "").lower()
        is_male = "муж" in gender
        
        # Проверяем семейное положение в паспорте
        marital_status = (passport.get("Семейное_положение") or "").lower()
        
        # Проверяем наличие свидетельства о браке
        has_marriage = False
        spouse_fio = ""
        spouse_dob = ""
        
        if data_map:
            marriage_certs = data_map.get("свидетельство_о_браке", [])
            if marriage_certs:
                has_marriage = True
                # Берем данные из первого свидетельства
                cert = marriage_certs[0]
                if isinstance(cert, dict):
                    # Определяем, кто из супругов - это должник
                    # Сравниваем ФИО из паспорта с ФИО супруга и супруги в свидетельстве
                    passport_fio = passport.get("ФИО", "").lower()
                    cert_male_fio = (cert.get("Супруг_ФИО") or "").lower()
                    cert_female_fio = (cert.get("Супруга_ФИО") or "").lower()
                    
                    # Если должник - мужчина и его ФИО совпадает с супругом в свидетельстве
                    if is_male and passport_fio == cert_male_fio:
                        spouse_fio = cert.get("Супруга_ФИО", "")
                        spouse_dob = cert.get("Супруга_Дата_рождения", "")
                    # Если должник - женщина и её ФИО совпадает с супругой в свидетельстве
                    elif not is_male and passport_fio == cert_female_fio:
                        spouse_fio = cert.get("Супруг_ФИО", "")
                        spouse_dob = cert.get("Супруг_Дата_рождения", "")
                    # Если не удалось сопоставить по ФИО, берем противоположный пол
                    elif is_male:
                        spouse_fio = cert.get("Супруга_ФИО", "")
                        spouse_dob = cert.get("Супруга_Дата_рождения", "")
                    else:
                        spouse_fio = cert.get("Супруг_ФИО", "")
                        spouse_dob = cert.get("Супруг_Дата_рождения", "")
        
        # Проверяем свидетельство о разводе
        has_divorce = False
        if data_map:
            divorce_certs = data_map.get("свидетельство_о_разводе", [])
            if divorce_certs:
                has_divorce = True
        
        # Формируем ответ
        is_married = has_marriage or "женат" in marital_status or "замужем" in marital_status
        not_married = "не женат" in marital_status or "не замужем" in marital_status or (has_divorce and not has_marriage)
        
        if not_married or not is_married:
            return "Нет"
        
        # Если в браке, формируем текст
        if is_male:
            status = "женат"
            spouse_title = "супруга"
        else:
            status = "замужем"
            spouse_title = "супруг"
        
        if spouse_fio and spouse_dob:
            return f"{status}, {spouse_title} {spouse_fio} {spouse_dob} г.р."
        elif spouse_fio:
            return f"{status}, {spouse_title} {spouse_fio}"
        else:
            return status.capitalize()

    @staticmethod
    def extract_real_estate_from_notifications(notification_list: List[Dict[str, Any]], owner_fio: str = "") -> List[str]:
        """Извлекает информацию о недвижимости из уведомлений ЕГРН об отсутствии."""
        descriptions = []

        # Извлекаем из уведомлений
        for notification in notification_list:
            # Проверяем, что это уведомление об отсутствии
            if notification.get("Результат") != "сведения отсутствуют":
                continue

            # Проверяем правообладателя
            holder = notification.get("Правообладатель", {})
            holder_fio = holder.get("ФИО", "") if isinstance(holder, dict) else ""

            # Если есть территория (адрес объекта), значит запрос был об этом объекте
            territory = notification.get("Территория", "")

            if territory:
                # Формируем описание из доступных данных
                # Примечание: В уведомлении нет полных данных, но есть адрес
                parts = []
                parts.append("жилой дом")  # предполагаем тип по контексту
                parts.append("общая долевая собственность")
                parts.append("доля не указана")  # без конфига не знаем долю
                parts.append(f"местонахождение: {territory}")

                # Если есть информация о другом правообладателе
                if holder_fio and holder_fio != owner_fio:
                    parts.append(f"(сособственник: {holder_fio})")

                descriptions.append(", ".join(parts))

        return descriptions

    @staticmethod
    def format_real_estate_detailed(data_list: List[Dict[str, Any]], owner_fio: str = "", notification_list: Optional[List[Dict[str, Any]]] = None) -> str:
        """Форматирует недвижимость в детальном виде, фильтруя по ФИО владельца.

        Учитывает как выписки ЕГРН с полными данными, так и уведомления об отсутствии,
        которые могут указывать на долевую собственность.
        """
        descriptions: List[str] = []

        # Обрабатываем полные выписки ЕГРН
        if data_list:
            for data in data_list:
                obj = data.get("Объект") or {}
                kadaster = data.get("Кадастровый_номер", "")
                owners = data.get("Правообладатели", [])

                # Если указано ФИО владельца, проверяем, является ли он правообладателем
                if owner_fio and owners:
                    owner_found = False
                    owner_info = None
                    for owner in owners:
                        if isinstance(owner, dict):
                            owner_name = owner.get("ФИО", "")
                            if owner_name and owner_fio.lower() in owner_name.lower():
                                owner_found = True
                                owner_info = owner
                                break

                    # Если владелец не найден среди правообладателей, пропускаем этот объект
                    if not owner_found:
                        continue
                else:
                    # Если ФИО не указано, берем первого владельца
                    owner_info = owners[0] if owners and isinstance(owners, list) and len(owners) > 0 else None

                # Собираем информацию
                vid = obj.get("Вид", "").lower()
                address = obj.get("Адрес", "")
                area = obj.get("Площадь", "")

                parts = []

                # Вид объекта
                if vid:
                    parts.append(vid)

                # Тип собственности и доля
                if owners and isinstance(owners, list) and len(owners) > 0:
                    ownership_type = "общая долевая собственность" if len(owners) > 1 else "индивидуальная собственность"
                    parts.append(ownership_type)

                    # Доля конкретного владельца
                    if owner_info:
                        share = owner_info.get("Доля", "")
                        if share and share != "1/1":
                            parts.append(f"{share} доля")

                # Кадастровый номер
                if kadaster:
                    parts.append(f"кадастровый номер: {kadaster}")

                # Площадь
                if area:
                    parts.append(f"площадь: {area} кв. м.")

                # Местонахождение
                if address:
                    parts.append(f"местонахождение: {address}")

                # Основание регистрации
                if owner_info:
                    doc = owner_info.get("Документ", "")
                    reg_date = owner_info.get("Дата_регистрации", "")
                    if doc:
                        base_text = f"основание регистрации: {doc}"
                        if reg_date:
                            base_text += f", выдан {reg_date}"
                        parts.append(base_text)

                if parts:
                    descriptions.append(", ".join(parts))

        # ВАЖНО: Проверяем уведомления ЕГРН, которые могут указывать на долевую собственность
        if notification_list:
            notification_estates = DocumentProcessor.extract_real_estate_from_notifications(
                notification_list, owner_fio
            )
            descriptions.extend(notification_estates)

        return "; ".join(descriptions) if descriptions else "нет"

    @staticmethod
    def format_movable_property(data_list: List[Dict[str, Any]]) -> str:
        """Форматирует движимое имущество (транспорт из ГИБДД)."""
        if not data_list:
            return "нет"

        descriptions = []
        for data in data_list:
            # Проверяем, не снято ли ТС с учета (продано/утилизировано)
            special_notes = data.get("Особые_отметки", "")
            if special_notes and isinstance(special_notes, str):
                special_lower = special_notes.lower()
                # Пропускаем ТС, которые сняты с учета
                if any(keyword in special_lower for keyword in ["снято с учета", "продаж", "продан", "передач", "утилизац"]):
                    continue

            parts = []

            # Тип ТС
            ts_type = data.get("Тип_ТС", "")
            if ts_type:
                parts.append(ts_type)

            # Марка и модель
            brand_model = data.get("Марка_модель", "")
            if brand_model:
                parts.append(brand_model)

            # Год выпуска
            year = data.get("Год_выпуска", "")
            if year:
                parts.append(f"{year} года выпуска")

            # Государственный номер
            gov_num = data.get("Гос_номер", "")
            if gov_num:
                parts.append(f"гос. номер: {gov_num}")

            # VIN
            vin = data.get("VIN", "")
            if vin:
                parts.append(f"VIN: {vin}")

            # Дата регистрации
            doc = data.get("Документ", {})
            if isinstance(doc, dict):
                reg_date = doc.get("Дата_регистрации", "")
                if reg_date:
                    parts.append(f"дата регистрации: {reg_date}")

            if parts:
                descriptions.append(", ".join(parts))

        return "; ".join(descriptions) if descriptions else "нет"

    @staticmethod
    def format_shares(data_list: List[Dict[str, Any]]) -> str:
        """Форматирует акции и участие в организациях."""
        if not data_list:
            return "нет"

        descriptions = []
        for data in data_list:
            parts = []

            # Название организации
            org = data.get("Организация", {})
            if isinstance(org, dict):
                org_name = org.get("Название", "")
                org_form = org.get("Форма", "")
                org_inn = org.get("ИНН", "")

                if org_name:
                    if org_form:
                        parts.append(f"{org_form} \"{org_name}\"")
                    else:
                        parts.append(f"\"{org_name}\"")

                    if org_inn:
                        parts.append(f"ИНН: {org_inn}")

            # Доля участия
            participant = data.get("Участник", {})
            if isinstance(participant, dict):
                share = participant.get("Доля", "")
                if share:
                    parts.append(f"доля: {share}")

                nominal = participant.get("Номинальная_стоимость", "")
                if nominal:
                    parts.append(f"номинальная стоимость: {nominal}")

            if parts:
                descriptions.append(", ".join(parts))

        return "; ".join(descriptions) if descriptions else "нет"

    @staticmethod
    def format_securities(data_list: List[Dict[str, Any]]) -> str:
        """Форматирует ценные бумаги."""
        if not data_list:
            return "нет"

        descriptions = []
        for data in data_list:
            securities_list = data.get("Ценные_бумаги", [])
            depositary = data.get("Депозитарий", "")
            account = data.get("Номер_счета", "")
            total_value = data.get("Общая_стоимость", "")

            if securities_list:
                for sec in securities_list:
                    parts = []

                    # Тип и эмитент
                    sec_type = sec.get("Тип", "")
                    emitent = sec.get("Эмитент", "")

                    if sec_type:
                        parts.append(sec_type)
                    if emitent:
                        parts.append(f"эмитент: {emitent}")

                    # Количество и стоимость
                    quantity = sec.get("Количество", "")
                    value = sec.get("Текущая_стоимость", "")

                    if quantity:
                        parts.append(f"количество: {quantity}")
                    if value:
                        parts.append(f"стоимость: {value}")

                    # ISIN
                    isin = sec.get("ISIN", "")
                    if isin:
                        parts.append(f"ISIN: {isin}")

                    if parts:
                        descriptions.append(", ".join(parts))

            # Если нет детализации, но есть общая информация
            if not descriptions and (depositary or total_value):
                parts = []
                if depositary:
                    parts.append(f"депозитарий: {depositary}")
                if account:
                    parts.append(f"счет: {account}")
                if total_value:
                    parts.append(f"общая стоимость портфеля: {total_value}")
                if parts:
                    descriptions.append(", ".join(parts))

        return "; ".join(descriptions) if descriptions else "нет"

    @staticmethod
    def format_cash_valuables(data_list: List[Dict[str, Any]]) -> str:
        """Форматирует наличные денежные средства и иное ценное имущество (драгоценности, искусство, коллекции)."""
        if not data_list:
            return "нет"

        descriptions = []

        for data in data_list:
            # Наличные денежные средства
            cash = data.get("Наличные_средства", {})
            if isinstance(cash, dict):
                cash_parts = []
                for currency, amount in cash.items():
                    if amount:
                        if currency == "RUB":
                            cash_parts.append(f"{amount} руб.")
                        elif currency == "USD":
                            cash_parts.append(f"{amount} долларов США")
                        elif currency == "EUR":
                            cash_parts.append(f"{amount} евро")
                        else:
                            cash_parts.append(f"{amount} ({currency})")

                if cash_parts:
                    descriptions.append("наличные денежные средства: " + ", ".join(cash_parts))

            # Имущество (драгоценности, искусство и т.д.)
            items = data.get("Имущество", [])
            for item in items:
                parts = []

                category = item.get("Категория", "")
                description = item.get("Описание", "")
                characteristics = item.get("Характеристики", "")
                value = item.get("Оценочная_стоимость", "")

                # Категория и описание
                if category:
                    parts.append(category)
                if description:
                    parts.append(description)

                # Характеристики
                if characteristics:
                    parts.append(characteristics)

                # Стоимость
                if value:
                    parts.append(f"оценочная стоимость: {value}")

                if parts:
                    descriptions.append(", ".join(parts))

            # Общая стоимость (если указана отдельно)
            total = data.get("Общая_стоимость", "")
            if total and not items:  # Если нет детализации, но есть общая сумма
                descriptions.append(f"имущество на общую сумму: {total}")

        return "; ".join(descriptions) if descriptions else "нет"

    @staticmethod
    def format_property_rights(data_list: List[Dict[str, Any]]) -> str:
        """Форматирует имущественные права (дебиторская задолженность).

        ВАЖНО: Фильтрует только те документы, где владелец = КРЕДИТОР.
        Если владелец = ДОЛЖНИК, это не имущественное право, а обязательство!
        """
        if not data_list:
            return "нет"

        descriptions = []
        for data in data_list:
            # КРИТИЧЕСКИ ВАЖНО: Проверяем роль владельца документа
            # Имущественное право = владелец является КРЕДИТОРОМ (ему должны)
            # Если владелец = должник/заёмщик - это обязательство, не право!
            role = data.get("Роль_владельца_документа", "")
            if role:
                role_lower = role.lower()
                # Пропускаем если владелец - должник или заёмщик (это его долг, не право)
                if any(keyword in role_lower for keyword in ["должник", "заемщик", "заёмщик"]):
                    continue
                # Принимаем только если владелец - кредитор (ему должны)
                if "кредитор" not in role_lower:
                    continue

            parts = []

            # Тип документа
            doc_type = data.get("Тип", "")
            if doc_type:
                parts.append(doc_type)

            # Должник (кто должен)
            debtor = data.get("Должник", "")
            if debtor:
                parts.append(f"должник: {debtor}")

            # Сумма
            amount = data.get("Сумма", "")
            if amount:
                parts.append(f"сумма: {amount}")

            # Номер договора/дела
            doc_num = data.get("Номер", "")
            doc_date = data.get("Дата", "")
            if doc_num:
                if doc_date:
                    parts.append(f"документ: {doc_num} от {doc_date}")
                else:
                    parts.append(f"документ: {doc_num}")

            # Срок
            term = data.get("Срок", "")
            if term:
                parts.append(f"срок: {term}")

            if parts:
                descriptions.append(", ".join(parts))

        return "; ".join(descriptions) if descriptions else "нет"

    @staticmethod
    def format_other_income(pension_data: List[Dict[str, Any]], payment_data: List[Dict[str, Any]]) -> str:
        """Форматирует информацию об иных доходах (пособия, ЕДВ, подработки)."""
        descriptions = []

        # Обрабатываем данные из документов "пенсии" (назначенные выплаты)
        for doc in pension_data:
            benefits = doc.get("Выплаты", [])
            if not benefits:
                continue

            for benefit in benefits:
                benefit_type = benefit.get("Вид", "")
                amount = benefit.get("Размер", "")

                if benefit_type and amount:
                    # Формируем описание типа выплаты
                    benefit_lower = benefit_type.lower()

                    # Определяем правильную формулировку
                    if "едв" in benefit_lower or "ежемесячная денежная выплата" in benefit_lower:
                        desc = f"Должник является получателем ежемесячной денежной выплаты"
                        # Уточняем категорию, если указана
                        if "ветеран" in benefit_lower:
                            desc += " ветеранам"
                        elif "инвалид" in benefit_lower:
                            desc += " инвалидам"
                        elif "радиац" in benefit_lower:
                            desc += " ветеранам, инвалидам и гражданам, подвергшимся воздействию радиации"
                    elif "пособи" in benefit_lower:
                        desc = f"Должник получает пособие ({benefit_type})"
                    elif "пенси" in benefit_lower:
                        # Пенсию не включаем в иные доходы - она указывается отдельно
                        continue
                    else:
                        desc = f"Должник получает выплату: {benefit_type}"

                    # Добавляем размер
                    desc += f" в размере {amount}"

                    # Добавляем период, если указан
                    period = benefit.get("Период", {})
                    if isinstance(period, dict):
                        period_from = period.get("С", "")
                        period_to = period.get("По", "")
                        if period_from or period_to:
                            if period_to and period_to.lower() == "бессрочно":
                                desc += " (бессрочно)"
                            elif period_from and period_to:
                                desc += f" (с {period_from} по {period_to})"

                    desc += "."
                    descriptions.append(desc)

        # Обрабатываем данные из документов "выплаты" (фактические выплаты за период)
        for doc in payment_data:
            payments = doc.get("Выплаты", [])
            if not payments:
                continue

            for payment in payments:
                payment_name = payment.get("Наименование", "")
                amount = payment.get("Размер", "")

                if payment_name and amount:
                    payment_lower = payment_name.lower()

                    # Пропускаем пенсии
                    if "пенси" in payment_lower:
                        continue

                    # Формируем описание
                    if "едв" in payment_lower or "ежемесячная денежная выплата" in payment_lower:
                        desc = f"Должник получает ежемесячную денежную выплату в размере {amount}."
                    elif "пособи" in payment_lower:
                        desc = f"Должник получает пособие ({payment_name}) в размере {amount}."
                    else:
                        desc = f"Должник получает выплату: {payment_name} в размере {amount}."

                    descriptions.append(desc)

        # Убираем дубликаты - сравниваем по типу выплаты и сумме
        unique_descriptions = []
        seen_benefits = []

        import re

        for desc in descriptions:
            # Извлекаем ключевые слова для сравнения
            desc_lower = desc.lower()

            # Извлекаем тип выплаты из ОТФОРМАТИРОВАННОГО описания
            benefit_type = ""
            if "ежемесячная денежная выплата" in desc_lower:
                benefit_type = "едв"
            elif "пособи" in desc_lower:
                benefit_type = "пособие"
            elif "выплату:" in desc_lower:
                # Извлекаем название после "выплату:"
                match = re.search(r'выплату:\s*([^в]+?)\s+в размере', desc_lower)
                if match:
                    benefit_type = match.group(1).strip()
                else:
                    benefit_type = "прочая_выплата"
            else:
                benefit_type = "прочая_выплата"

            # Извлекаем сумму и нормализуем её
            # Ищем все числа в строке
            amounts = re.findall(r'\d+', desc)
            if amounts:
                # Объединяем первые два числа как основную сумму (рубли и копейки)
                if len(amounts) >= 2:
                    normalized_amount = f"{amounts[0]}.{amounts[1]}"
                else:
                    normalized_amount = amounts[0]
            else:
                normalized_amount = ""

            # Проверяем, не видели ли мы уже такую выплату
            benefit_signature = (benefit_type, normalized_amount)
            if benefit_signature not in seen_benefits:
                seen_benefits.append(benefit_signature)
                unique_descriptions.append(desc)

        # Формируем итоговый текст
        if unique_descriptions:
            result = " ".join(unique_descriptions)
            result += " Иного дохода не имеет."
            return result
        else:
            return "Иного дохода не имеет."

    @staticmethod
    def number_to_words_rubles(amount: Decimal) -> str:
        """Конвертирует число в текст прописью для рублей и копеек."""
        try:
            from num2words import num2words
            
            rubles = int(amount)
            kopeks = int((amount - rubles) * 100)

            # Используем num2words для конвертации в слова
            words = num2words(rubles, lang='ru')

            # Форматируем результат
            rubles_formatted = f"{rubles:,}".replace(",", " ")
            result = f"{rubles_formatted} ({words}) руб. {kopeks:02d} коп."
            return result
        except Exception as e:
            # Fallback: если библиотека не работает, возвращаем просто число
            rubles = int(amount)
            kopeks = int((amount - rubles) * 100)
            rubles_formatted = f"{rubles:,}".replace(",", " ")
            return f"{rubles_formatted} руб. {kopeks:02d} коп."

    @staticmethod
    def check_marital_and_children_status(passport: Dict[str, Any], data_map: Dict[str, List[Dict[str, Any]]] = None) -> str:
        """Проверяет семейное положение и наличие детей.
        
        Args:
            passport: данные паспорта
            data_map: словарь всех документов (для проверки свидетельств)
        """
        marital_status = (passport.get("Семейное_положение") or "").lower() if passport else ""
        children = passport.get("Дети", []) if passport else []

        # Проверяем наличие несовершеннолетних детей из паспорта
        has_minors = False
        passport_children_count = 0
        
        if children:
            today = date.today()
            for child in children:
                if not isinstance(child, dict):
                    continue
                passport_children_count += 1
                dob_str = child.get("Дата_рождения")
                if dob_str:
                    try:
                        dob = datetime.strptime(dob_str, "%d.%m.%Y").date()
                        age_years = (today - dob).days / 365.25
                        if age_years < 18:
                            has_minors = True
                            break
                    except ValueError:
                        continue

        # ДОПОЛНИТЕЛЬНО: Проверяем свидетельства о рождении детей
        if data_map:
            birth_certificates = data_map.get("свидетельство_о_рождении", [])
            if birth_certificates:
                today = date.today()
                for cert in birth_certificates:
                    if not isinstance(cert, dict):
                        continue
                    dob_str = cert.get("Дата_рождения")
                    if dob_str:
                        try:
                            dob = datetime.strptime(dob_str, "%d.%m.%Y").date()
                            age_years = (today - dob).days / 365.25
                            if age_years < 18:
                                has_minors = True
                                break
                        except ValueError:
                            continue

        # Проверяем свидетельство о браке
        has_marriage = False
        if data_map:
            marriage_certs = data_map.get("свидетельство_о_браке", [])
            if marriage_certs:
                has_marriage = True

        # Проверяем свидетельство о расторжении брака
        has_divorce = False
        if data_map:
            divorce_certs = data_map.get("свидетельство_о_разводе", [])
            if divorce_certs:
                has_divorce = True

        # Проверяем, не в браке ли
        not_married = "не женат" in marital_status or "не замужем" in marital_status or (has_divorce and not has_marriage)

        # Формируем текст о семейном положении
        parts = []

        # Информация о браке
        if not_married:
            parts.append("Должник в настоящее время в браке не состоит")
        else:
            # Если в браке (есть свидетельство или указано в паспорте)
            if has_marriage or "женат" in marital_status or "замужем" in marital_status:
                parts.append("Должник состоит в браке")
            elif "разведен" in marital_status or "разведена" in marital_status:
                parts.append("Должник разведен")

        # Информация о детях
        if not has_minors:
            parts.append("несовершеннолетних детей на иждивении не имеет")
        else:
            parts.append("имеет несовершеннолетних детей на иждивении")

        if parts:
            result = ", ".join(parts) + "."
            return result

        return ""

    @staticmethod
    def calculate_average_income(data_list: List[Dict[str, Any]]) -> Optional[Decimal]:
        latest_year: Optional[int] = None
        latest_amount: Optional[Decimal] = None
        for data in data_list:
            for statement in data.get("Справки", []) or []:
                year_raw = statement.get("Год")
                try:
                    year = int(str(year_raw))
                except (TypeError, ValueError):
                    year = None
                amount = DocumentProcessor.parse_decimal(statement.get("Общая_сумма_дохода"))
                if amount is None:
                    continue
                if latest_year is None or (year is not None and year > latest_year):
                    latest_year = year
                    latest_amount = amount
        if latest_amount is None:
            return None
        months = Decimal(12)
        return (latest_amount / months) if months else None

    @staticmethod
    def format_creditors_table(data_map: Dict[str, List[Dict[str, Any]]], debtor_fio: str = "", debtor_inn: str = "", debtor_snils: str = "", debtor_address: str = "") -> Dict[str, str]:
        """Генерирует данные для таблицы 'Список кредиторов и должников гражданина'.

        Возвращает словарь с ключами для подстановки в шаблон Word.

        ВАЖНО: НЕ объединяет дубли - каждый кредит идет отдельной строкой.
        Группировка только для нумерации (1.1, 1.2 от одного кредитора).

        Args:
            data_map: словарь с данными документов
            debtor_fio: ФИО должника (из паспорта)
            debtor_inn: ИНН должника
            debtor_snils: СНИЛС должника
            debtor_address: Адрес регистрации должника
        """
        from collections import defaultdict

        # ИСПОЛЬЗУЕМ merge_credit_reports для получения объединенного списка с учетом справок
        merged_credits = DocumentProcessor.merge_credit_reports(data_map)
        
        # Конвертируем объединенные кредиты в формат для таблицы
        all_credits_list = []
        
        for entry in merged_credits:
            if not isinstance(entry, dict):
                continue

            кредитор = entry.get("Кредитор", "").strip()
            if not кредитор:
                continue

            # Данные уже обработаны в merge_credit_reports
            сумма = entry.get("Сумма_задолженности", Decimal(0))
            if сумма <= 0:
                continue

            # Нормализация имени
            кредитор_normalized, кредитор_canonical = DocumentProcessor.normalize_bank_name(кредитор)

            # Получаем данные (уже обработанные в merge_credit_reports)
            инн_кредитора = entry.get("ИНН_кредитора") or ""
            огрн_кредитора = entry.get("ОГРН_кредитора") or ""
            
            # Если ИНН нет, пробуем получить из реестра ЦБ РФ
            if not инн_кредитора:
                инн_кредитора = DocumentProcessor.get_bank_inn(кредитор_canonical)

            # Получаем адрес
            адрес_из_документа = entry.get("Адрес") or entry.get("Адрес_кредитора") or ""
            адрес_из_реестра = DocumentProcessor.get_bank_address(кредитор_canonical)
            адрес_банка = адрес_из_документа or адрес_из_реестра

            тип_кредита = entry.get("Вид") or entry.get("Тип_кредита") or "Потребительский кредит"
            дата_договора = entry.get("Дата_договора") or ""
            сумма_обязательства = entry.get("Сумма_обязательства") or Decimal(0)
            текущая = entry.get("Текущая_задолженность") or Decimal(0)
            просрочка = entry.get("Просрочка") or entry.get("Текущая_просрочка") or Decimal(0)

            all_credits_list.append({
                "Кредитор": кредитор,
                "Кредитор_canonical": кредитор_canonical,
                "Кредитор_normalized": кредитор_normalized,
                "ИНН_кредитора": инн_кредитора,
                "ОГРН_кредитора": огрн_кредитора,
                "Тип_кредита": тип_кредита,
                "Дата_договора": дата_договора,
                "Сумма_обязательства": сумма_обязательства,
                "Адрес_кредитора": адрес_банка,
                "Текущая_задолженность": текущая,
                "Просрочка": просрочка,
                "Сумма": сумма,
                "Штрафы_пени": просрочка,
            })

        # merge_credit_reports уже сделал дедупликацию, НЕ делаем её повторно!
        # Используем credit напрямую без дополнительной дедупликации
        # (дедупликация уже сделана в merge_credit_reports с учётом первоначальной суммы)
        unique_credits = {
            f"{credit['Кредитор_normalized']}|{credit['Дата_договора']}|{credit.get('Сумма_обязательства', 0)}": credit
            for credit in all_credits_list
        }

        # Группируем уникальные кредиты по нормализованному имени кредитора
        credits_by_creditor = defaultdict(list)
        for credit in unique_credits.values():
            кредитор_normalized = credit["Кредитор_normalized"]
            credits_by_creditor[кредитор_normalized].append(credit)

        # Сортируем кредиторов по общей сумме всех их кредитов (убывание)
        sorted_creditors = sorted(
            credits_by_creditor.items(),
            key=lambda x: sum(c["Сумма"] for c in x[1]),
            reverse=True
        )

        # Генерируем строки таблицы - ГРУППИРУЕМ ПО БАНКАМ
        table_rows = []
        counter = 1

        for кредитор_normalized, credits_list in sorted_creditors:
            # Каждый договор = отдельная строка в таблице
            первый_кредит = credits_list[0]
            
            # ИСПОЛЬЗУЕМ КАНОНИЧЕСКОЕ НАЗВАНИЕ (правильное форматирование)
            кредитор_display = первый_кредит["Кредитор_canonical"]

            # Адрес: приоритет полному адресу из реестра ЦБ РФ
            адрес_из_реестра = DocumentProcessor.get_bank_address(кредитор_display)
            адрес_из_документа = первый_кредит["Адрес_кредитора"]

            # Если адрес из реестра длиннее (полный), используем его
            if адрес_из_реестра and len(адрес_из_реестра) > 20:
                адрес = адрес_из_реестра
            else:
                адрес = адрес_из_документа or адрес_из_реестра

            # ИНН кредитора
            инн_display = первый_кредит.get("ИНН_кредитора") or DocumentProcessor.get_bank_inn(кредитор_display)
            # Добавляем префикс "ИНН " если ИНН найден
            if инн_display:
                инн_display = f"ИНН {инн_display}"

            # Создаем отдельную строку для каждого договора
            for contract_idx, credit in enumerate(credits_list):
                is_first_contract = (contract_idx == 0)
                
                тип_кредита = credit["Тип_кредита"]
                дата_текст = f"Договор от {credit['Дата_договора']}" if credit['Дата_договора'] else ""
                сумма_текст = f"{credit['Сумма']:.2f}"
                
                пп = f"1.{counter}" if is_first_contract else ""
                
                table_rows.append({
                    "пп_кредит": пп,
                    "Тип_кредита": тип_кредита,
                    "Кредитор": кредитор_display if is_first_contract else "",
                    "ИНН_кредитора": инн_display if is_first_contract else "",
                    "Адрес_кредитора": адрес if is_first_contract else "",
                    "Дата_договора": дата_текст,
                    "Полная_сумма_обязательства": сумма_текст,
                    "Задолженность_в_том_числе": сумма_текст,
                    "Штрафы_пени_и_другое": "0.00",
                    # Флаг для объединения ячеек
                    "is_first_contract": is_first_contract,
                    # Данные должника
                    "Фамилия": debtor_fio.split()[0] if debtor_fio and len(debtor_fio.split()) > 0 else "",
                    "Имя": debtor_fio.split()[1] if debtor_fio and len(debtor_fio.split()) > 1 else "",
                    "Отчество": debtor_fio.split()[2] if debtor_fio and len(debtor_fio.split()) > 2 else "",
                    "ИНН": debtor_inn,
                    "Снилs": debtor_snils,
                    "Адрес_регистрации_должника": debtor_address,
                })
            
            counter += 1

        # Обязательные платежи (налоги, сборы из постановлений и налоговых уведомлений)
        # ВАЖНО: Налоги идут в разделе 2 (2.1, 2.2, 2.3...)
        tax_rows = []
        tax_counter = 1

        # Другие долги из постановлений (не налоги, не банки)
        # Идут в разделе 1 после банков (1.X, 1.X+1, ...)
        other_debts = []

        # 1. Извлекаем ВСЕ постановления пристава
        for постановление in data_map.get("постановление_пристава", []):
            взыскатель = (постановление.get("Взыскатель") or "").strip()
            взыскатель_lower = взыскатель.lower()

            сумма_str = постановление.get("Итого_взыскание") or постановление.get("Сумма_долга") or ""
            сумма = DocumentProcessor.parse_decimal(сумма_str) or Decimal(0)

            if сумма <= 0:
                continue

            # Разделяем: налоги в раздел 2, остальные долги в раздел 1
            if any(kw in взыскатель_lower for kw in ["налог", "ифнс", "фнс", "инспекция федеральной налоговой службы"]):
                # Это налог - в раздел 2
                tax_rows.append({
                    "пп_обяз_платеж": f"2.{tax_counter}",
                    "Налог_сбор_или_иной_обяз_платеж": взыскатель,
                    "Сумма_обяз_платежа": f"{сумма:.2f}",
                    "Штрафы_пени_и_другое_обяз_платежа": "0.00",
                })
                tax_counter += 1
            else:
                # Это другой долг (не налог, не банк) - в раздел 1
                # Получаем дополнительные данные
                номер_ип = постановление.get("Номер_ИП") or постановление.get("Номер") or ""
                дата_ип = постановление.get("Дата_постановления") or постановление.get("Дата_возбуждения") or постановление.get("Дата") or ""
                
                # Предмет исполнения (тип долга)
                предмет = постановление.get("Предмет_исполнения") or "Взыскание по постановлению ФССП"
                
                # Адрес взыскателя
                адрес_взыскателя = постановление.get("Адрес_взыскателя") or ""
                # Очищаем лишние запятые и пробелы
                if адрес_взыскателя:
                    адрес_взыскателя = ", ".join(filter(None, [x.strip() for x in адрес_взыскателя.split(",")]))
                
                # Информация об органе, выдавшем документ + номер дела
                орган = постановление.get("Орган_выдавший") or ""
                адрес_органа = постановление.get("Адрес_органа") or ""
                номер_дела = постановление.get("Номер_дела") or ""
                
                # Формируем информацию для поля "Дата_договора"
                дата_display = []
                if орган:
                    орган_clean = ", ".join(filter(None, [x.strip() for x in орган.split(",")]))
                    дата_display.append(орган_clean)
                if адрес_органа:
                    адрес_органа_clean = ", ".join(filter(None, [x.strip() for x in адрес_органа.split(",")]))
                    дата_display.append(f"Адрес: {адрес_органа_clean}")
                if номер_дела:
                    дата_display.append(f"по делу № {номер_дела}")
                
                дата_договора_text = " ".join(дата_display) if дата_display else дата_ип

                # Нормализуем название взыскателя для группировки
                взыскатель_normalized = (
                    взыскатель
                    .replace("Общество с ограниченной ответственностью", "ООО")
                    .replace("ОБЩЕСТВО С ОГРАНИЧЕННОЙ ОТВЕТСТВЕННОСТЬЮ", "ООО")
                    .replace("Публичное акционерное общество", "ПАО")
                    .replace("ПУБЛИЧНОЕ АКЦИОНЕРНОЕ ОБЩЕСТВО", "ПАО")
                    .replace("Акционерное общество", "АО")
                    .replace("АКЦИОНЕРНОЕ ОБЩЕСТВО", "АО")
                    .replace('"', '')
                    .strip()
                )

                other_debts.append({
                    "Кредитор": взыскатель_normalized,
                    "Адрес_кредитора": адрес_взыскателя,
                    "Тип_кредита": предмет,
                    "Дата_договора": дата_договора_text,
                    "Номер_ИП": номер_ип,
                    "Сумма": сумма,
                })

        # 2. Извлекаем налоги из налоговых уведомлений
        for уведомление in data_map.get("налоговое_уведомление", []):
            налоги = уведомление.get("Налоги", [])
            for налог in налоги:
                if not isinstance(налог, dict):
                    continue

                сумма = DocumentProcessor.parse_decimal(налог.get("Сумма")) or Decimal(0)
                if сумма <= 0:
                    continue

                вид = налог.get("Вид", "Налог")
                период = налог.get("Период", "")

                # Формируем название
                if период:
                    название = f"{вид} за {период} г."
                else:
                    название = вид

                tax_rows.append({
                    "пп_обяз_платеж": f"2.{tax_counter}",
                    "Налог_сбор_или_иной_обяз_платеж": название,
                    "Сумма_обяз_платежа": f"{сумма:.2f}",
                    "Штрафы_пени_и_другое_обяз_платежа": "0.00",
                })
                tax_counter += 1

        # 3. Добавляем другие долги (из постановлений, не налоги) в раздел 1 ПОСЛЕ банков
        for debt in other_debts:
            table_rows.append({
                "пп_кредит": f"1.{counter}",
                "Тип_кредита": debt["Тип_кредита"],
                "Кредитор": debt["Кредитор"],
                "Адрес_кредитора": debt["Адрес_кредитора"],
                "Дата_договора": debt["Дата_договора"],
                "Полная_сумма_обязательства": f"{debt['Сумма']:.2f}",
                "Задолженность_в_том_числе": f"{debt['Сумма']:.2f}",
                "Штрафы_пени_и_другое": "0.00",
                # Данные должника
                "Фамилия": debtor_fio.split()[0] if debtor_fio and len(debtor_fio.split()) > 0 else "",
                "Имя": debtor_fio.split()[1] if debtor_fio and len(debtor_fio.split()) > 1 else "",
                "Отчество": debtor_fio.split()[2] if debtor_fio and len(debtor_fio.split()) > 2 else "",
                "ИНН": debtor_inn,
                "Снилс": debtor_snils,
                "Адрес_регистрации_должника": debtor_address,
            })
            counter += 1

        # Формируем результат
        result = {}

        # ДЛЯ ДИНАМИЧЕСКИХ ТАБЛИЦ: возвращаем списки объектов
        result["credits"] = table_rows  # Список всех кредитов
        result["taxes"] = tax_rows      # Список всех налогов

        # СТАРЫЙ ФОРМАТ: для совместимости с простыми шаблонами
        # Добавляем ВСЕ кредиты с номерами
        for i, row in enumerate(table_rows):
            for key, value in row.items():
                # Создаем уникальные ключи для каждой строки
                # Например: пп_кредит_1, пп_кредит_2, ...
                result[f"{key}_{i+1}"] = value

        # Также добавляем первый кредит БЕЗ номера (для совместимости)
        if table_rows:
            for key, value in table_rows[0].items():
                result[key] = value

        # Добавляем общее количество кредитов
        result["количество_кредитов"] = str(len(table_rows))

        # Если есть налоги - добавляем все
        for i, row in enumerate(tax_rows):
            for key, value in row.items():
                result[f"{key}_{i+1}"] = value

        # Первый налог БЕЗ номера
        if tax_rows:
            for key, value in tax_rows[0].items():
                result[key] = value

        result["количество_налогов"] = str(len(tax_rows))

        return result

    @staticmethod
    def format_bank_accounts_table(счета_docs: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Формирует таблицу банковских счетов для описи имущества.

        Args:
            счета_docs: список документов типа "счета"

        Returns:
            Словарь с ключом "счета" (список для Jinja2)
        """
        счета_rows = []
        counter = 1

        for doc in счета_docs:
            счета_list = doc.get("Счета", [])

            for счет in счета_list:
                if not isinstance(счет, dict):
                    continue

                банк = счет.get("Банк") or ""
                if not банк:
                    continue

                # Нормализуем название банка (убираем лишние слова)
                банк_normalized = (
                    банк.replace("Общество с ограниченной ответственностью", "ООО")
                    .replace("Публичное акционерное общество", "ПАО")
                    .replace("Акционерное общество", "АО")
                    .replace("АКЦИОНЕРНОЕ ОБЩЕСТВО", "АО")
                )

                # Для адреса берем только основное название
                if "," in банк_normalized:
                    адрес_банка = банк_normalized.split(",")[0].strip()
                else:
                    адрес_банка = банк_normalized

                тип_счета = счет.get("Тип") or счет.get("Статус") or ""
                номер = счет.get("Номер") or ""
                дата_открытия = счет.get("Дата_открытия") or ""
                остаток = счет.get("Остаток") or ""

                # Если остаток "0.00" или "0" - оставляем пустым
                if остаток in ("0.00", "0", "None"):
                    остаток = ""

                счета_rows.append({
                    "счета_пп": f"3.{counter}",
                    "Наименование_и_адрес_банка_или_иной_кредитной_организации": адрес_банка,
                    "Вид_счета": тип_счета,
                    "Дата_открытия_счета": дата_открытия,
                    "Остаток_на_счете": остаток,
                })
                counter += 1

        return {"счета": счета_rows}

    @staticmethod
    def format_realty_table(егрн_docs: List[Dict[str, Any]], owner_fio: str = "") -> Dict[str, Any]:
        """Формирует таблицу недвижимости для описи имущества.

        Args:
            егрн_docs: список документов типа "егрн_выписка"
            owner_fio: ФИО владельца (из паспорта) для фильтрации

        Returns:
            Словарь с ключами для таблиц недвижимости
        """
        земельные = []
        жилые_дома = []
        квартиры = []
        гаражи = []
        иное_недвижимое = []

        земля_counter = 1
        дом_counter = 1
        квартира_counter = 1
        гараж_counter = 1
        иное_counter = 1

        for doc in егрн_docs:
            if not isinstance(doc, dict):
                continue

            # Проверяем если это уведомление об отсутствии - пропускаем
            if doc.get("Результат") == "сведения отсутствуют":
                continue

            # Получаем правообладателей
            правообладатели = doc.get("Правообладатели", [])

            # Проверяем есть ли наш человек среди правообладателей
            owner_found = False
            owner_data = None

            for право in правообладатели:
                фио = право.get("ФИО", "")
                if owner_fio and owner_fio in фио:
                    owner_found = True
                    owner_data = право
                    break

            # Если не нашли владельца - пропускаем
            if owner_fio and not owner_found:
                continue

            # Получаем данные объекта - могут быть как на верхнем уровне, так и в "Объект"
            объект = doc.get("Объект", {})

            кадастр = doc.get("Кадастровый_номер", "")
            адрес = объект.get("Адрес") or doc.get("Адрес", "")
            площадь = объект.get("Площадь") or doc.get("Площадь", "")
            тип_объекта = объект.get("Вид") or doc.get("Тип_объекта", "")
            назначение = объект.get("Назначение", "")

            # Определяем вид собственности и долю
            if owner_data:
                вид_собственности = owner_data.get("Вид_права", "")
                доля = owner_data.get("Доля", "")
                документ_основание = owner_data.get("Документ", "")
            else:
                вид_собственности = ""
                доля = ""
                документ_основание = ""

            # Формируем основание приобретения
            if доля:
                основание = f"{документ_основание}. Доля в праве: {доля}" if документ_основание else f"Доля в праве: {доля}"
            else:
                основание = документ_основание or ""

            # Обременения
            обременения = doc.get("Обременения", [])
            if isinstance(обременения, list) and обременения:
                залогодержатель = "; ".join(str(о) for о in обременения if о)
            else:
                залогодержатель = ""

            # Создаем базовый объект
            base_obj = {
                "Вид_собственности": вид_собственности,
                "Местонахождение_адрес": адрес,
                "Площадь": площадь,
                "Основание_приобретения_и_стоимость": основание,
                "Сведения_о_залоге_и_залогодержателе": залогодержатель,
            }

            # Определяем категорию и добавляем в соответствующий список
            тип_lower = тип_объекта.lower() if тип_объекта else ""
            назначение_lower = назначение.lower() if назначение else ""
            адрес_lower = адрес.lower() if адрес else ""

            if "земельн" in тип_lower or "участок" in тип_lower:
                земельные.append({
                    **base_obj,
                    "Кадастровый_номер": кадастр,
                    "Номер_в_списке": f"{земля_counter})" if len([x for x in егрн_docs if x.get('Объект', {}).get('Вид', '').lower().find('земельн') >= 0]) > 1 else "",
                })
                земля_counter += 1

            elif ("здание" in тип_lower and "жил" in назначение_lower) or "жилой дом" in тип_lower:
                # Название с номером если домов несколько
                название = f"{дом_counter}) жилой дом" if дом_counter > 1 or len(жилые_дома) > 0 else "жилой дом"
                жилые_дома.append({
                    **base_obj,
                    "Вид_и_наименование": название,
                })
                дом_counter += 1

            elif "квартир" in тип_lower or "комнат" in тип_lower or ("здание" in тип_lower and "квартир" in адрес_lower):
                название = f"{квартира_counter}) {тип_объекта or 'Квартира'}" if квартира_counter > 1 or len(квартиры) > 0 else тип_объекта or "Квартира"
                квартиры.append({
                    **base_obj,
                    "Вид_и_наименование": название,
                })
                квартира_counter += 1

            elif "гараж" in тип_lower or "бокс" in тип_lower or "машино-место" in тип_lower:
                название = f"{гараж_counter}) {тип_объекта}" if гараж_counter > 1 or len(гаражи) > 0 else тип_объекта
                гаражи.append({
                    **base_obj,
                    "Вид_и_наименование": название,
                })
                гараж_counter += 1

            else:
                # Иное недвижимое имущество
                название = f"{иное_counter}) {тип_объекта or назначение or 'Недвижимость'}" if иное_counter > 1 or len(иное_недвижимое) > 0 else (тип_объекта or назначение or "Недвижимость")
                иное_недвижимое.append({
                    **base_obj,
                    "Вид_и_наименование_имущества": название,
                })
                иное_counter += 1

        # Если списки пустые, добавляем по одному заполнителю с пустыми полями.
        # Это предотвращает удаление строк в шаблоне при рендеринге docxtpl
        # — вместо удаления строки будет отрендерена пустая строка, сохраняя макет.
        if not земельные:
            земельные.append({
                "Кадастровый_номер": "",
                "Вид_собственности": "",
                "Местонахождение_адрес": "",
                "Площадь": "",
                "Основание_приобретения_и_стоимость": "",
                "Сведения_о_залоге_и_залогодержателе": "",
                "Номер_в_списке": "",
            })

        if not жилые_дома:
            жилые_дома.append({
                "Вид_и_наименование": "",
                "Вид_собственности": "",
                "Местонахождение_адрес": "",
                "Площадь": "",
                "Основание_приобретения_и_стоимость": "",
                "Сведения_о_залоге_и_залогодержателе": "",
            })

        if not квартиры:
            квартиры.append({
                "Вид_и_наименование": "",
                "Вид_собственности": "",
                "Местонахождение_адрес": "",
                "Площадь": "",
                "Основание_приобретения_и_стоимость": "",
                "Сведения_о_залоге_и_залогодержателе": "",
            })

        if not гаражи:
            гаражи.append({
                "Вид_и_наименование": "",
                "Вид_собственности": "",
                "Местонахождение_адрес": "",
                "Площадь": "",
                "Основание_приобретения_и_стоимость": "",
                "Сведения_о_залоге_и_залогодержателе": "",
            })

        if not иное_недвижимое:
            иное_недвижимое.append({
                "Вид_и_наименование_имущества": "",
                "Вид_собственности": "",
                "Местонахождение_адрес": "",
                "Площадь": "",
                "Основание_приобретения_и_стоимость": "",
                "Сведения_о_залоге_и_залогодержателе": "",
            })

        return {
            "земельные_участки": земельные,
            "жилые_дома": жилые_дома,
            "квартиры": квартиры,
            "гаражи": гаражи,
            "иное_недвижимое": иное_недвижимое,
        }

    @staticmethod
    def format_vehicles_table(гибдд_docs: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Формирует таблицу транспортных средств для описи имущества.

        Args:
            гибдд_docs: список документов типа "гибдд"

        Returns:
            Словарь с ключом "автомобили" (список для Jinja2) и "Нету_гибдд" (текст если справки нет)
        """
        автомобили = []
        counter = 1
        
        # Проверяем, есть ли справка ГИБДД
        has_gibdd = len(гибдд_docs) > 0

        for doc in гибдд_docs:
            if not isinstance(doc, dict):
                continue

            # Проверяем особые отметки
            special_notes = doc.get("Особые_отметки", "")
            if special_notes:
                special_lower = special_notes.lower()
                # Пропускаем если ТС отсутствует в реестре
                if any(keyword in special_lower for keyword in 
                       ["отсутствуют", "отсутствует", "не зарегистрировано"]):
                    continue
                # Пропускаем проданные/снятые с учета
                if any(keyword in special_lower for keyword in 
                       ["снято с учета", "продаж", "продан", "передач", "утилизац"]):
                    continue

            марка = doc.get("Марка_модель") or ""
            вин = doc.get("VIN") or ""
            год = doc.get("Год_выпуска") or ""
            номер = doc.get("Регистрационный_знак") or doc.get("Номер") or ""

            # Идентификационный номер - это VIN
            id_номер = вин

            # Вид собственности и место нахождения - пока не известны
            вид_собственности = ""
            место = ""
            стоимость = ""
            залог = ""

            автомобили.append({
                "авто_пп": f"2.1.{counter}",
                "Вид_марка_модель": марка,
                "Идентификационный_номер": id_номер,
                "Вид_собственности": вид_собственности,
                "Место_нахождения": место,
                "Стоимость": стоимость,
                "Сведения_о_залоге": залог,
            })
            counter += 1
        
        # Формируем текст для случая отсутствия справки ГИБДД
        # Текст появляется ТОЛЬКО если справки нет вообще (not has_gibdd)
        # Если справка есть, но машин нет - текст НЕ выводится
        gibdd_notice = ""
        if not has_gibdd:
            gibdd_notice = "Должник направил заявление в ГИБДД на получение справки о зарегистрированных транспортных средствах, на дату подачи заявления справка не получена, обязуется предоставить до даты первого судебного заседания."

        return {
            "автомобили": автомобили,
            "Нету_гибдд": gibdd_notice
        }

    @staticmethod
    def normalize_date(date_str: str) -> str:
        """Нормализует дату к формату ДД.ММ.ГГГГ.
        
        Примеры:
        - "09-09-2009" → "09.09.2009"
        - "09/09/2009" → "09.09.2009"
        - "09.09.2009" → "09.09.2009"
        """
        if not date_str:
            return ""
        
        # Заменяем дефисы и слэши на точки
        normalized = date_str.replace("-", ".").replace("/", ".")
        
        return normalized.strip()
    
    @staticmethod
    def merge_credit_reports(data_map: Dict[str, List[Dict[str, Any]]]) -> List[Dict[str, Any]]:
        """Объединяет кредиты из ОКБ, БКИ, НБКИ отчетов, убирает дубликаты.

        Дедупликация по ИНН/ОГРН + дата договора (не только по названию кредитора).
        Возвращает список уникальных кредитов для таблицы "Список кредиторов".
        """
        all_credits = {}  # {ключ_дедупликации: данные_кредита}
        seen_keys = set()  # для отладки

        print("\n" + "="*80)
        print("ДЕДУПЛИКАЦИЯ КРЕДИТОВ")
        print("="*80)

        for key in ("отчет_окб", "отчет_бки", "отчет_нбки"):
            reports_count = len(data_map.get(key, []))
            if reports_count > 0:
                print(f"\n📄 Обработка отчета: {key.upper()} ({reports_count} шт.)")
            
            for report in data_map.get(key, []):
                collection = (
                    report.get("Кредиты")
                    or report.get("Договоры")
                    or []
                )

                for entry in collection:
                    if not isinstance(entry, dict):
                        continue

                    кредитор = (entry.get("Кредитор") or "").strip()
                    if not кредитор:
                        continue
                    
                    print(f"\n   → Извлечен: {кредитор}")

                    # УЛУЧШЕННАЯ НОРМАЛИЗАЦИЯ: используем новую функцию
                    кредитор_normalized, кредитор_canonical = DocumentProcessor.normalize_bank_name(кредитор)

                    # Определяем тип кредитора
                    кредитор_lower = кредитор.lower()
                    if any(word in кредитор_lower for word in ["мфо", "мкк", "мфк", "микрофинанс", "микрокредит"]):
                        тип_кредитора = "МФО"
                    else:
                        тип_кредитора = "БАНК"

                    # Вычисляем сумму долга
                    основной = DocumentProcessor.parse_decimal(entry.get("Основной_долг"))
                    проценты = DocumentProcessor.parse_decimal(entry.get("Проценты"))
                    штрафы = DocumentProcessor.parse_decimal(entry.get("Штрафы"))
                    
                    # Инициализируем переменные для текущей задолженности и просрочки
                    текущая = DocumentProcessor.parse_decimal(entry.get("Текущая_задолженность"))
                    просрочка = DocumentProcessor.parse_decimal(entry.get("Просрочка") or entry.get("Текущая_просрочка"))

                    if основной or проценты or штрафы:
                        сумма = (основной or Decimal(0)) + (проценты or Decimal(0)) + (штрафы or Decimal(0))
                    else:
                        # Для кредитных отчетов: берем поле "Сумма" (уже сложенную нейронкой)
                        сумма = DocumentProcessor.parse_decimal(entry.get("Сумма")) or Decimal(0)
                        
                        # Если поля "Сумма" нет, складываем текущую и просрочку
                        if сумма <= 0:
                            сумма = (текущая or Decimal(0)) + (просрочка or Decimal(0))

                    # Пропускаем кредиты с нулевой задолженностью
                    if сумма <= 0:
                        continue

                    # === ЛОГИКА ДЕДУПЛИКАЦИИ: НАЗВАНИЕ + ДАТА ДОГОВОРА + ПЕРВОНАЧАЛЬНАЯ СУММА ===
                    # Извлекаем дату договора из разных полей
                    дата_договора_raw = (entry.get("Дата_сделки") or entry.get("Дата_начала_договора") or entry.get("Дата_договора") or "").strip()
                    
                    # НОРМАЛИЗУЕМ ДАТУ: 09-09-2009 → 09.09.2009
                    дата_договора = DocumentProcessor.normalize_date(дата_договора_raw)
                    
                    # Извлекаем ИНН/ОГРН для сохранения (но не для дедупликации)
                    инн = (entry.get("ИНН_кредитора") or entry.get("ИНН") or "").strip()
                    огрн = (entry.get("ОГРН_кредитора") or entry.get("ОГРН") or "").strip()
                    
                    # Первоначальная сумма кредита (сколько взяли изначально)
                    сумма_обязательства = DocumentProcessor.parse_decimal(entry.get("Сумма_обязательства")) or Decimal(0)
                    
                    print(f"      • Дата договора: {дата_договора or 'НЕТ'} (исходная: {дата_договора_raw})")
                    print(f"      • Сумма обязательства: {сумма_обязательства if сумма_обязательства > 0 else 'НЕТ'}")
                    print(f"      • Текущий долг: {сумма}")

                    # Формируем ключ дедупликации:
                    # КЛЮЧ: кредитор + дата + первоначальная сумма (БЕЗ текущей суммы долга!)
                    # Текущая сумма долга может отличаться в ОКБ и БКИ, поэтому не используем её в ключе
                    if сумма_обязательства > 100:
                        сумма_для_ключа = int(сумма_обязательства)
                        dedup_key = f"{кредитор_normalized}|{дата_договора}|{сумма_для_ключа}"
                    else:
                        # Нет первоначальной суммы - используем текущий долг для различения
                        текущая_сумма_для_ключа = f"{сумма:.2f}"
                        dedup_key = f"{кредитор_normalized}|{дата_договора}|NO_INIT|{текущая_сумма_для_ключа}"
                    
                    # Проверяем дубликаты с учётом погрешности дат (±1 день)
                    # Это нужно для случаев когда ОКБ и БКИ указывают разные даты для одного договора
                    found_similar = False
                    similar_key = None
                    
                    if дата_договора and сумма_обязательства > 100:
                        from datetime import datetime, timedelta
                        try:
                            base_date = datetime.strptime(дата_договора, "%d.%m.%Y")
                            # Проверяем ±1 день по кредитору + дата + первоначальная сумма
                            for delta in [-1, 0, 1]:
                                check_date = (base_date + timedelta(days=delta)).strftime("%d.%m.%Y")
                                check_key = f"{кредитор_normalized}|{check_date}|{сумма_для_ключа}"
                                if check_key in all_credits and check_key != dedup_key:
                                    found_similar = True
                                    similar_key = check_key
                                    break
                        except:
                            pass

                    # Проверяем, встречался ли уже такой кредит (точное совпадение или с погрешностью ±1 день)
                    target_key = similar_key if found_similar else dedup_key
                    
                    if target_key in all_credits:
                        # Дубликат найден — берём запись с большей суммой (более актуальные данные)
                        existing_sum = all_credits[target_key].get("Сумма_задолженности", Decimal(0))
                        if сумма > existing_sum:
                            if found_similar and target_key != dedup_key:
                                print(f"      ✓ ДУБЛИКАТ ±1день (обновлён): {existing_sum} → {сумма}")
                            else:
                                print(f"      ✓ ДУБЛИКАТ (обновлён): {existing_sum} → {сумма}")
                            print(f"      Ключ: {target_key}")
                            all_credits[target_key] = {
                                "Кредитор": кредитор_canonical,
                                "ИНН_кредитора": инн or None,
                                "ОГРН_кредитора": огрн or None,
                                "Дата_договора": дата_договора or None,
                                "Сумма_обязательства": сумма_обязательства,
                                "Сумма_задолженности": сумма,
                                "Тип_кредитора": тип_кредитора,
                                "Текущая_задолженность": текущая,
                                "Текущая_просрочка": просрочка,
                                "Основной_долг": основной,
                                "Проценты": проценты,
                                "Штрафы": штрафы,
                                "Просрочка": просрочка,
                                "Источник": key,
                            }
                        else:
                            if found_similar and target_key != dedup_key:
                                print(f"      ✓ ДУБЛИКАТ ±1день (пропущен): {сумма} <= {existing_sum}")
                            else:
                                print(f"      ✓ ДУБЛИКАТ (пропущен): {сумма} <= {existing_sum}")
                            print(f"      Ключ: {target_key}")
                    else:
                        # Новый кредит — добавляем
                        print(f"      ✓ НОВЫЙ кредит добавлен")
                        print(f"      Ключ: {dedup_key}")
                        all_credits[dedup_key] = {
                            "Кредитор": кредитор_canonical,
                            "ИНН_кредитора": инн or None,
                            "ОГРН_кредитора": огрн or None,
                            "Дата_договора": дата_договора or None,
                            "Сумма_обязательства": сумма_обязательства,
                            "Сумма_задолженности": сумма,
                            "Тип_кредитора": тип_кредитора,
                            "Текущая_задолженность": текущая,
                            "Текущая_просрочка": просрочка,
                            "Основной_долг": основной,
                            "Проценты": проценты,
                            "Штрафы": штрафы,
                            "Просрочка": просрочка,
                            "Источник": key,
                        }

        # === ДОБАВЛЯЕМ СПРАВКИ О ЗАДОЛЖЕННОСТИ ===
        # Справки - это официальные документы от кредиторов с актуальной суммой долга
        for справка in data_map.get("справка_о_задолженности", []):
            кредитор = (справка.get("Кредитор") or "").strip()
            if not кредитор:
                continue

            кредитор_normalized, кредитор_canonical = DocumentProcessor.normalize_bank_name(кредитор)

            # Извлекаем итоговую сумму задолженности из справки
            итого = справка.get("Итого_задолженность") or справка.get("Всего_задолженность") or справка.get("Сумма_задолженности")
            сумма = DocumentProcessor.parse_decimal(итого)
            
            if not сумма or сумма <= 0:
                # Если итоговой суммы нет, пробуем сложить компоненты
                основной = DocumentProcessor.parse_decimal(справка.get("Основной_долг"))
                проценты = DocumentProcessor.parse_decimal(справка.get("Проценты"))
                штрафы = DocumentProcessor.parse_decimal(справка.get("Штрафы"))
                сумма = (основной or Decimal(0)) + (проценты or Decimal(0)) + (штрафы or Decimal(0))

            if сумма <= 0:
                continue

            # Определяем тип кредитора
            кредитор_lower = кредитор.lower()
            if any(word in кредитор_lower for word in ["мфо", "мкк", "мфк", "микрофинанс", "микрокредит"]):
                тип_кредитора = "МФО"
            else:
                тип_кредитора = "БАНК"

            дата_договора = (справка.get("Дата_договора") or справка.get("Дата") or "").strip()
            инн = (справка.get("ИНН") or "").strip()
            огрн = (справка.get("ОГРН") or "").strip()
            
            # Для справок используем текущую сумму долга в ключе
            сумма_для_ключа = int(сумма) if сумма else 0

            # Ключ дедупликации: название + дата + текущая сумма
            dedup_key = f"{кредитор_normalized}|{дата_договора}|{сумма_для_ключа}"

            # Справки имеют приоритет - они содержат актуальные данные от кредитора
            if dedup_key not in all_credits:
                print(f"      [СПРАВКА] Добавлен {кредитор_canonical}: {сумма} руб. (дата: {дата_договора})")
                all_credits[dedup_key] = {
                    "Кредитор": кредитор_canonical,
                    "ИНН_кредитора": инн or None,
                    "ОГРН_кредитора": огрн or None,
                    "Дата_договора": дата_договора or None,
                    "Сумма_задолженности": сумма,
                    "Тип_кредитора": тип_кредитора,
                    "Текущая_задолженность": DocumentProcessor.parse_decimal(справка.get("Основной_долг")),
                    "Текущая_просрочка": None,
                    "Основной_долг": DocumentProcessor.parse_decimal(справка.get("Основной_долг")),
                    "Проценты": DocumentProcessor.parse_decimal(справка.get("Проценты")),
                    "Штрафы": DocumentProcessor.parse_decimal(справка.get("Штрафы")),
                    "Просрочка": None,
                    "Источник": "справка_о_задолженности",
                }
            else:
                # Если уже есть в отчетах, обновляем если сумма больше (справка актуальнее)
                existing_sum = all_credits[dedup_key].get("Сумма_задолженности", Decimal(0))
                if сумма > existing_sum:
                    print(f"      [СПРАВКА] Обновление {кредитор_canonical}: {existing_sum} → {сумма} руб.")
                    all_credits[dedup_key]["Сумма_задолженности"] = сумма
                    all_credits[dedup_key]["Источник"] = "справка_о_задолженности"

        # Сортируем по убыванию суммы
        result = sorted(all_credits.values(), key=lambda x: x["Сумма_задолженности"], reverse=True)
        
        print("\n" + "="*80)
        print(f"ИТОГО УНИКАЛЬНЫХ КРЕДИТОВ: {len(result)}")
        print("="*80)
        
        return result

    @staticmethod
    def calculate_total_debt(data_map: Dict[str, List[Dict[str, Any]]]) -> Optional[Decimal]:
        """Рассчитывает общую сумму долга из ВСЕХ источников.

        Источники задолженности:
        1. Кредитные отчеты (ОКБ, БКИ) - объединяем все уникальные кредиты
        2. Справки о задолженности от кредиторов
        3. Постановления приставов (ФССП)

        Приоритет:
        1. Автоматический расчёт: сумма всех источников
        """

        total = Decimal(0)
        has_value = False

        # === 1. КРЕДИТНЫЕ ОТЧЕТЫ (ОКБ + БКИ) ===
        # Объединяем все уникальные кредиты из обоих отчетов
        merged_credits = DocumentProcessor.merge_credit_reports(data_map)

        if merged_credits:
            # Суммируем все уникальные кредиты
            credits_total = sum(
                credit.get("Сумма_задолженности", Decimal(0)) 
                for credit in merged_credits
            )
            if credits_total > 0:
                total += credits_total
                has_value = True

        # === 2. ПОСТАНОВЛЕНИЯ ПРИСТАВОВ ===
        for постановление in data_map.get("постановление_пристава", []):
            # Берем итоговую сумму взыскания
            взыскание = постановление.get("Итого_взыскание") or постановление.get("Сумма_долга")
            if взыскание:
                parsed = DocumentProcessor.parse_decimal(взыскание)
                if parsed and parsed > 0:
                    total += parsed
                    has_value = True

        # === 3. НАЛОГОВЫЕ УВЕДОМЛЕНИЯ ===
        for уведомление in data_map.get("налоговое_уведомление", []):
            # Сначала пробуем взять общую сумму "Всего к уплате"
            всего_к_уплате = DocumentProcessor.parse_decimal(уведомление.get("Всего_к_уплате"))
            if всего_к_уплате and всего_к_уплате > 0:
                total += всего_к_уплате
                has_value = True
                print(f"      [TAX] Налоговое уведомление: всего к уплате {всего_к_уплате}")
            else:
                # Если общей суммы нет, суммируем по каждому налогу
                налоги = уведомление.get("Налоги", [])
                for налог in налоги:
                    if isinstance(налог, dict):
                        сумма = DocumentProcessor.parse_decimal(налог.get("Сумма"))
                        if сумма and сумма > 0:
                            total += сумма
                            has_value = True

        return total if has_value else None

    @staticmethod
    def convert_to_genitive_initials(full_name: str) -> str:
        if not full_name:
            return ""
        prompt = (
            "Преобразуй ФИО в форму 'Фамилии И.О.' в родительном падеже."
            " Верни только результат без пояснений и дополнительных знаков.\n\n"
            f"ФИО: {full_name}"
        )
        try:
            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {"role": "user", "content": prompt}
                ],
            )
            result = response.choices[0].message.content.strip()
            return result.splitlines()[0]
        except Exception:
            return ""

    @staticmethod
    def convert_to_genitive_full(full_name: str) -> str:
        """Преобразует ФИО в родительный падеж (кого? - Кузьмича Николая Павловича)."""
        if not full_name:
            return ""
        prompt = (
            "Преобразуй ФИО в родительный падеж (кого?)."
            " Верни только результат без пояснений и дополнительных знаков.\n\n"
            f"ФИО: {full_name}\n"
            "Пример: Иванов Иван Иванович → Иванова Ивана Ивановича"
        )
        try:
            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {"role": "user", "content": prompt}
                ],
            )
            result = response.choices[0].message.content.strip()
            return result.splitlines()[0]
        except Exception:
            return ""

    @staticmethod
    def convert_to_dative_initials(full_name: str) -> str:
        """Преобразует ФИО в форму 'Фамилии И.О.' в дательном падеже (кому?)."""
        if not full_name:
            return ""
        prompt = (
            "Преобразуй ФИО в форму 'Фамилии И.О.' в дательном падеже (кому?)."
            " Верни только результат без пояснений и дополнительных знаков.\n\n"
            f"ФИО: {full_name}"
        )
        try:
            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {"role": "user", "content": prompt}
                ],
            )
            result = response.choices[0].message.content.strip()
            return result.splitlines()[0]
        except Exception:
            return ""

    @staticmethod
    def convert_to_dative_full(full_name: str) -> str:
        """Преобразует ФИО в дательный падеж (кому? - Кузьмичу Николаю Павловичу)."""
        if not full_name:
            return ""
        prompt = (
            "Преобразуй ФИО в дательный падеж (кому?)."
            " Верни только результат без пояснений и дополнительных знаков.\n\n"
            f"ФИО: {full_name}\n"
            "Пример: Иванов Иван Иванович → Иванову Ивану Ивановичу"
        )
        try:
            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {"role": "user", "content": prompt}
                ],
            )
            result = response.choices[0].message.content.strip()
            return result.splitlines()[0]
        except Exception:
            return ""

    @staticmethod
    def convert_to_accusative_full(full_name: str) -> str:
        """Преобразует ФИО в винительный падеж (кого? - Кузьмича Николая Павловича)."""
        if not full_name:
            return ""
        prompt = (
            "Преобразуй ФИО в винительный падеж (кого?)."
            " Верни только результат без пояснений и дополнительных знаков.\n\n"
            f"ФИО: {full_name}\n"
            "Пример: Иванов Иван Иванович → Иванова Ивана Ивановича"
        )
        try:
            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {"role": "user", "content": prompt}
                ],
            )
            result = response.choices[0].message.content.strip()
            return result.splitlines()[0]
        except Exception:
            return ""

    @staticmethod
    def detect_gender(full_name: str) -> str:
        """Определяет пол по ФИО. Возвращает 'м' или 'ж'."""
        if not full_name:
            return "м"

        # Простая логика: если отчество заканчивается на 'вна' или 'чна' - женский
        parts = full_name.split()
        if len(parts) >= 3:
            patronymic = parts[2].lower()
            if patronymic.endswith('вна') or patronymic.endswith('ична'):
                return "ж"

        # Если не определили по отчеству, используем GPT
        prompt = (
            "Определи пол человека по ФИО. Верни ТОЛЬКО одну букву: 'м' для мужского или 'ж' для женского пола."
            " Никаких пояснений, только буква.\n\n"
            f"ФИО: {full_name}"
        )
        try:
            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {"role": "user", "content": prompt}
                ],
            )
            result = response.choices[0].message.content.strip().lower()
            if 'ж' in result:
                return "ж"
            else:
                return "м"
        except Exception:
            return "м"

    @staticmethod
    def get_gender_pronoun(gender: str, case: str = "accusative") -> str:
        """Возвращает местоимение в зависимости от пола и падежа."""
        if case == "accusative":  # винительный падеж (признании его/её)
            return "её" if gender == "ж" else "его"
        elif case == "genitive":  # родительный падеж (у него/неё, в отношении него/неё)
            return "неё" if gender == "ж" else "него"
        elif case == "dative":  # дательный падеж (ему/ей)
            return "ей" if gender == "ж" else "ему"
        else:
            return "его" if gender == "м" else "её"

    @staticmethod
    def parse_address_with_gpt(full_address: str, openai_client) -> Dict[str, str]:
        """Парсит адрес прописки на компоненты через GPT."""
        result = {
            "субъект": "",
            "район": "",
            "город": "",
            "населенный_пункт": "",
            "улица": "",
            "дом": "",
            "корпус": "",
            "квартира": "",
        }

        if not full_address or not openai_client:
            return result

        prompt = f"""Разбери адрес на компоненты. Верни ТОЛЬКО JSON без дополнительного текста.

Адрес: {full_address}

JSON формат:
{{
  "субъект": "область/край/республика (например: Новосибирская область, Краснодарский край)",
  "район": "район (если есть, например: Центральный район)",
  "город": "город (например: Новосибирск, город Москва)",
  "населенный_пункт": "поселок/село/деревня (если есть вместо города)",
  "улица": "улица/проспект/переулок с названием (например: ул. Ленина, проспект Мира)",
  "дом": "номер дома (только цифры и буквы, например: 10, 5А)",
  "корпус": "номер корпуса/строения (если есть, например: 2, 1А)",
  "квартира": "номер квартиры (только цифры, например: 45)"
}}

Если компонента нет в адресе - оставь пустую строку "".
"""

        try:
            response = openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}],
            )
            
            response_text = response.choices[0].message.content.strip()
            
            # Очистка JSON
            cleaned = DocumentProcessor.clean_json_response(response_text)
            if cleaned:
                parsed = json.loads(cleaned)
                for key in result.keys():
                    if key in parsed and parsed[key]:
                        result[key] = str(parsed[key]).strip()
        except Exception as e:
            print(f"      [WARNING] Не удалось разобрать адрес через GPT: {e}")
            # Fallback на regex парсинг
            return DocumentProcessor.parse_address(full_address)

        return result

    @staticmethod
    def parse_address(full_address: str) -> Dict[str, str]:
        """Парсит адрес прописки на компоненты."""
        import re

        result = {
            "субъект": "",
            "район": "",
            "город": "",
            "населенный_пункт": "",
            "улица": "",
            "дом": "",
            "корпус": "",
            "квартира": "",
        }

        if not full_address:
            return result

        # Простой парсинг по ключевым словам
        addr = full_address

        # Субъект (область, край, республика)
        if "область" in addr.lower():
            match = re.search(r'([^,]+область)', addr, re.IGNORECASE)
            if match:
                result["субъект"] = match.group(1).strip()
        elif "край" in addr.lower():
            match = re.search(r'([^,]+край)', addr, re.IGNORECASE)
            if match:
                result["субъект"] = match.group(1).strip()
        elif "республика" in addr.lower():
            match = re.search(r'([^,]+Республика[^,]*)', addr, re.IGNORECASE)
            if match:
                result["субъект"] = match.group(1).strip()

        # Район
        if "район" in addr.lower():
            match = re.search(r'([^,]*район[^,]*)', addr, re.IGNORECASE)
            if match:
                result["район"] = match.group(1).strip()

        # Город
        if re.search(r'\bгород\b|\bгор\.|г\.', addr, re.IGNORECASE):
            match = re.search(r'(?:город|гор\.|г\.)\s*([^,]+)', addr, re.IGNORECASE)
            if match:
                result["город"] = match.group(1).strip()
        elif re.search(r'\b[Гг]ород\s+\w+', addr):
            match = re.search(r'[Гг]ород\s+(\w+)', addr)
            if match:
                result["город"] = match.group(1).strip()

        # Улица, проспект, переулок
        if re.search(r'\b(?:улица|ул\.|проспект|пр-кт|пр\.|переулок|пер\.)', addr, re.IGNORECASE):
            match = re.search(r'(?:улица|ул\.|проспект|пр-кт|пр\.|переулок|пер\.)\s*([^,]+)', addr, re.IGNORECASE)
            if match:
                result["улица"] = match.group(1).strip()

        # Дом
        if re.search(r'\bдом\b|\bд\.', addr, re.IGNORECASE):
            match = re.search(r'(?:дом|д\.)\s*(\d+[а-яА-Я]?)', addr, re.IGNORECASE)
            if match:
                result["дом"] = match.group(1).strip()

        # Корпус
        if re.search(r'\bкорпус\b|\bкорп\.|к\.', addr, re.IGNORECASE):
            match = re.search(r'(?:корпус|корп\.|к\.)\s*(\d+[а-яА-Я]?)', addr, re.IGNORECASE)
            if match:
                result["корпус"] = match.group(1).strip()

        # Квартира
        if re.search(r'\bквартира\b|\bкв\.', addr, re.IGNORECASE):
            match = re.search(r'(?:квартира|кв\.)\s*(\d+)', addr, re.IGNORECASE)
            if match:
                result["квартира"] = match.group(1).strip()

        return result

    @staticmethod
    def extract_deals_from_all_documents(data_map: Dict[str, List[Dict[str, Any]]], owner_fio: str = "") -> List[Dict[str, Any]]:
        """Извлекает информацию о сделках из всех типов документов.

        Собирает сделки из:
        - Документов типа "сделки" (договоры купли-продажи, дарения)
        - ГИБДД (продажа автомобилей)
        - ЕГРН (продажа/дарение недвижимости)
        - Других документов с информацией о сделках

        Args:
            data_map: Словарь с данными всех документов
            owner_fio: ФИО должника для определения его роли в сделке

        Returns:
            Список всех сделок за последние 3 года
        """
        all_deals = []

        # 1. Сделки из документов типа "сделки"
        for deal in data_map.get("сделки", []):
            if isinstance(deal, dict):
                all_deals.append(deal)

        # 2. Сделки из документов ГИБДД (продажа автомобилей)
        for gibdd_doc in data_map.get("гибдд", []):
            if not isinstance(gibdd_doc, dict):
                continue

            sdelka = gibdd_doc.get("Сделка")
            if sdelka and isinstance(sdelka, dict) and sdelka.get("Есть_сделка"):
                # Формируем стандартную структуру сделки
                deal = {
                    "Тип_сделки": sdelka.get("Тип_сделки", "купля-продажа"),
                    "Дата_сделки": sdelka.get("Дата_сделки"),
                    "Роль_должника": None,
                    "Предмет_сделки": "автомобиль",
                    "Описание": gibdd_doc.get("Марка_модель", ""),
                    "Адрес_или_характеристики": f"VIN: {gibdd_doc.get('VIN', '')}, Гос. номер: {gibdd_doc.get('Гос_номер', '')}",
                    "Кадастровый_номер": None,
                    "Стоимость": sdelka.get("Стоимость"),
                    "Вторая_сторона": None,
                    "Особые_условия": gibdd_doc.get("Особые_отметки")
                }

                # Определяем роль должника
                seller = sdelka.get("Продавец_ФИО", "")
                buyer = sdelka.get("Покупатель_ФИО", "")

                if owner_fio and seller and owner_fio.lower() in seller.lower():
                    deal["Роль_должника"] = "продавец"
                    deal["Вторая_сторона"] = buyer
                elif owner_fio and buyer and owner_fio.lower() in buyer.lower():
                    deal["Роль_должника"] = "покупатель"
                    deal["Вторая_сторона"] = seller
                else:
                    # Если не можем определить - берем из документа
                    deal["Роль_должника"] = "продавец" if seller else "покупатель"
                    deal["Вторая_сторона"] = buyer or seller

                all_deals.append(deal)

        # 3. Сделки из документов ЕГРН (продажа/дарение недвижимости)
        for egrn_doc in data_map.get("егрн_выписка", []):
            if not isinstance(egrn_doc, dict):
                continue

            sdelka = egrn_doc.get("Сделка")
            if sdelka and isinstance(sdelka, dict) and sdelka.get("Есть_сделка"):
                # Формируем стандартную структуру сделки
                obj = egrn_doc.get("Объект", {})
                predmet = obj.get("Вид", "недвижимость")

                # Определяем тип предмета
                vid_lower = predmet.lower() if predmet else ""
                if "квартир" in vid_lower:
                    predmet_type = "квартира"
                elif "дом" in vid_lower or "жилое здание" in vid_lower:
                    predmet_type = "дом"
                elif "земел" in vid_lower or "участок" in vid_lower:
                    predmet_type = "земельный участок"
                else:
                    predmet_type = predmet or "недвижимость"

                deal = {
                    "Тип_сделки": sdelka.get("Тип_сделки", "купля-продажа"),
                    "Дата_сделки": sdelka.get("Дата_сделки"),
                    "Роль_должника": None,
                    "Предмет_сделки": predmet_type,
                    "Описание": f"{predmet}, площадь: {obj.get('Площадь', '')}",
                    "Адрес_или_характеристики": obj.get("Адрес", ""),
                    "Кадастровый_номер": egrn_doc.get("Кадастровый_номер"),
                    "Стоимость": sdelka.get("Стоимость") or egrn_doc.get("Кадастровая_стоимость"),
                    "Вторая_сторона": None,
                    "Особые_условия": None
                }

                # Определяем роль должника
                prev_owner = sdelka.get("Предыдущий_собственник", "")
                new_owner = sdelka.get("Новый_собственник", "")

                if owner_fio and prev_owner and owner_fio.lower() in prev_owner.lower():
                    deal["Роль_должника"] = "продавец"
                    deal["Вторая_сторона"] = new_owner
                elif owner_fio and new_owner and owner_fio.lower() in new_owner.lower():
                    deal["Роль_должника"] = "покупатель"
                    deal["Вторая_сторона"] = prev_owner
                else:
                    # Если не можем определить
                    deal["Роль_должника"] = "продавец" if prev_owner else "покупатель"
                    deal["Вторая_сторона"] = new_owner or prev_owner

                all_deals.append(deal)

        # Фильтруем по дате - только за последние 3 года
        from datetime import datetime, timedelta
        three_years_ago = datetime.now() - timedelta(days=3*365)

        filtered_deals = []
        for deal in all_deals:
            deal_date_str = deal.get("Дата_сделки")
            if not deal_date_str:
                # Если даты нет, всё равно включаем
                filtered_deals.append(deal)
                continue

            try:
                # Парсим дату в формате ДД.ММ.ГГГГ
                deal_date = datetime.strptime(deal_date_str, '%d.%m.%Y')
                if deal_date >= three_years_ago:
                    filtered_deals.append(deal)
            except (ValueError, TypeError):
                # Если не удалось распарсить дату, всё равно включаем
                filtered_deals.append(deal)

        # ДЕДУПЛИКАЦИЯ: Убираем дубликаты сделок с ТС по VIN и дате
        deduplicated_deals = []
        seen_vehicles = set()  # Для отслеживания уже добавленных ТС по (VIN, дата)
        
        for deal in filtered_deals:
            # Проверяем, является ли это сделкой с ТС
            if deal.get("Предмет_сделки") == "автомобиль":
                # Извлекаем VIN из адреса/характеристик
                addr_or_char = deal.get("Адрес_или_характеристики", "")
                vin = ""
                if "VIN:" in addr_or_char:
                    # Извлекаем VIN после "VIN:"
                    vin_start = addr_or_char.index("VIN:") + 4
                    vin_part = addr_or_char[vin_start:].split(",")[0].strip()
                    vin = vin_part
                
                deal_date = deal.get("Дата_сделки", "")
                
                # Создаем уникальный ключ (VIN + дата)
                if vin and deal_date:
                    vehicle_key = (vin, deal_date)
                    if vehicle_key in seen_vehicles:
                        # Это дубликат - пропускаем
                        continue
                    seen_vehicles.add(vehicle_key)
            
            # Добавляем сделку (либо не ТС, либо уникальная)
            deduplicated_deals.append(deal)

        return deduplicated_deals

    @staticmethod
    def get_arbitration_court(address: str) -> str:
        """Определяет арбитражный суд по адресу регистрации должника.

        Args:
            address: Полный адрес регистрации

        Returns:
            Название арбитражного суда (например, "Арбитражный суд Челябинской области")
        """
        if not address:
            return "Арбитражный суд"

        prompt = (
            "Определи название арбитражного суда по адресу регистрации должника."
            " Верни ТОЛЬКО название суда без пояснений.\n\n"
            "КРИТИЧЕСКИ ВАЖНО:\n"
            "- Для федеральных городов: 'Арбитражный суд города Москвы', 'Арбитражный суд города Санкт-Петербурга'\n"
            "- Для областей: 'Арбитражный суд [название области с окончанием] области'\n"
            "  * Челябинская область → Арбитражный суд Челябинской области\n"
            "  * Свердловская область → Арбитражный суд Свердловской области\n"
            "  * Новосибирская область → Арбитражный суд Новосибирской области\n"
            "  * Московская область → Арбитражный суд Московской области\n"
            "- Для краев: 'Арбитражный суд [название края с окончанием] края'\n"
            "  * Краснодарский край → Арбитражный суд Краснодарского края\n"
            "  * Красноярский край → Арбитражный суд Красноярского края\n"
            "  * Алтайский край → Арбитражный суд Алтайского края\n"
            "- Для республик: 'Арбитражный суд Республики [название]'\n"
            "  * Республика Башкортостан → Арбитражный суд Республики Башкортостан\n"
            "  * Республика Татарстан → Арбитражный суд Республики Татарстан\n"
            "  * Республика Крым → Арбитражный суд Республики Крым\n\n"
            f"Адрес регистрации: {address}\n\n"
            "Алгоритм:\n"
            "1. Найди в адресе название субъекта РФ (область/край/республика/город федерального значения)\n"
            "2. Преобразуй название в родительный падеж (кого? чего?)\n"
            "3. Добавь 'Арбитражный суд' + название субъекта в правильном падеже\n\n"
            "Примеры:\n"
            "- г. Челябинск, Челябинская область → Арбитражный суд Челябинской области\n"
            "- г. Москва → Арбитражный суд города Москвы\n"
            "- Краснодарский край, г. Краснодар → Арбитражный суд Краснодарского края\n"
            "- Республика Башкортостан, г. Уфа → Арбитражный суд Республики Башкортостан"
        )

        try:
            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {"role": "user", "content": prompt}
                ],
            )
            result = response.choices[0].message.content.strip()
            # Берем первую строку (на случай если GPT добавит пояснения)
            court_name = result.splitlines()[0].strip()
            return court_name
        except Exception:
            return "Арбитражный суд"

    @staticmethod
    def format_attachments(pdf_paths: List[Path]) -> str:
        """Форматирует список приложений из файлов (без расширения .pdf).

        Группирует одинаковые документы (например, 15 постановлений → "Постановления — 15 шт.")
        Убирает _ в конце имён файлов.
        """
        if not pdf_paths:
            return ""

        import re
        from collections import Counter

        # Обрабатываем имена файлов
        processed_names = []
        for path in pdf_paths:
            # Убираем расширение
            name = path.stem

            # ВАЖНО: Заменяем ВСЕ подчеркивания на пробелы (для читаемости)
            name = name.replace('_', ' ')

            # Удаляем цифры в начале строки (с точкой или без)
            # Паттерн: начало строки, цифры, необязательная точка, пробелы
            name_clean = re.sub(r'^\d+\.?\s*', '', name)

            # Убираем нумерацию в скобках типа (1), (2), (10) в конце
            # Паттерн: пробел, открывающая скобка, цифры, закрывающая скобка, конец строки
            name_clean = re.sub(r'\s*\(\d+\)\s*$', '', name_clean)

            # Убираем нумерацию типа _1_, _2_ в конце (теперь это пробелы + цифры + пробелы)
            name_clean = re.sub(r'\s+\d+\s*$', '', name_clean)
            
            # Убираем множественные пробелы
            name_clean = re.sub(r'\s+', ' ', name_clean).strip()

            processed_names.append(name_clean)

        # Подсчитываем количество одинаковых документов
        name_counts = Counter(processed_names)

        # Формируем список уникальных документов с количеством
        attachments = []
        seen = set()
        counter = 1

        for name_clean in processed_names:
            if name_clean in seen:
                continue

            seen.add(name_clean)
            count = name_counts[name_clean]

            if count > 1:
                # Несколько одинаковых документов - указываем количество
                attachments.append(f"{counter}. {name_clean} — {count} шт.")
            else:
                # Один документ
                attachments.append(f"{counter}. {name_clean}")

            counter += 1

        # Возвращаем пронумерованный список с переносами строк
        return "\n".join(attachments)

    @staticmethod
    def prepare_template_context(data_map: Dict[str, List[Dict[str, Any]]], pdf_paths: Optional[List[Path]] = None, openai_client=None) -> Dict[str, str]:
        passport = DocumentProcessor.select_first_entry(data_map, "паспорт")
        inn = DocumentProcessor.select_first_entry(data_map, "инн")
        snils = DocumentProcessor.select_first_entry(data_map, "снилс")
        labour = DocumentProcessor.select_first_entry(data_map, "трудовая")
        sziils = DocumentProcessor.select_first_entry(data_map, "сзиилс")
        
        # Документы супруга
        passport_spouse = DocumentProcessor.select_first_entry(data_map, "паспорт_супруга")
        inn_spouse = DocumentProcessor.select_first_entry(data_map, "инн_супруга")
        snils_spouse = DocumentProcessor.select_first_entry(data_map, "снилс_супруга")
        
        # Дополнительные источники данных
        criminal_record = DocumentProcessor.select_first_entry(data_map, "справка_о_судимости")
        tax_accounts = DocumentProcessor.select_first_entry(data_map, "налоговая_счета")
        credit_history = DocumentProcessor.select_first_entry(data_map, "отчет_окб")
        pension_account = DocumentProcessor.select_first_entry(data_map, "сзиилс")

        # === ПОЛУЧЕНИЕ ФИО ===
        # Приоритет: паспорт > ОКБ > справка о судимости > налоговая > электронная трудовая
        owner_fio = passport.get("ФИО", "") if passport else ""
        
        if not owner_fio and credit_history:
            owner_fio = credit_history.get("ФИО", "") or ""
        
        if not owner_fio and criminal_record:
            owner_fio = criminal_record.get("ФИО", "") or ""
        
        if not owner_fio and tax_accounts:
            owner_fio = tax_accounts.get("ФИО", "") or ""
        
        if not owner_fio and labour:
            owner_fio = labour.get("ФИО", "") or ""

        # === ПОЛУЧЕНИЕ ИНН ===
        # Приоритет: документ ИНН > справка о судимости > налоговая
        inn_number = ""
        for inn_doc in data_map.get("инн", []):
            if isinstance(inn_doc, dict):
                inn_value = inn_doc.get("ИНН")
                if inn_value and inn_value != "null":
                    inn_number = inn_value
                    break

        if not inn_number and inn:
            inn_number = inn.get("ИНН", "") or ""
        
        if not inn_number and criminal_record:
            inn_number = criminal_record.get("ИНН", "") or ""
        
        if not inn_number and tax_accounts:
            inn_number = tax_accounts.get("ИНН", "") or ""

        # === ПОЛУЧЕНИЕ СНИЛС ===
        # Приоритет: документ СНИЛС > лицевой счет ПФР > трудовая > СЗИИЛС
        snils_number = ""
        if snils:
            snils_number = snils.get("СНИЛС", "") or ""
        
        if not snils_number and pension_account:
            snils_number = pension_account.get("СНИЛС", "") or ""
        
        if not snils_number and labour:
            snils_number = labour.get("СНИЛС", "") or ""
        
        if not snils_number and sziils:
            snils_number = sziils.get("СНИЛС", "") or ""

        # Форматированная недвижимость (фильтруем по ФИО из паспорта)
        # Учитываем как полные выписки, так и уведомления об отсутствии (для долевой собственности)
        real_estate_detailed = DocumentProcessor.format_real_estate_detailed(
            data_map.get("егрн_выписка", []), 
            owner_fio=owner_fio,
            notification_list=data_map.get("егрн_уведомление", [])
        )

        average_income = DocumentProcessor.calculate_average_income(data_map.get("доходы", []))
        accounts_count = DocumentProcessor.calculate_bank_accounts(data_map.get("счета", []))

        # Получаем адрес прописки должника
        адрес_прописки = passport.get("Прописка", "") if passport else ""
        
        # Если адрес не в паспорте, проверяем в ОКБ/НБКИ
        if not адрес_прописки and credit_history:
            адрес_прописки = credit_history.get("Адрес_регистрации", "") or ""

        # Таблица кредиторов (передаем ФИО, ИНН, СНИЛС, адрес)
        # ВАЖНО: формируем таблицу ПЕРЕД расчетом общей суммы долга
        creditors_table_data = DocumentProcessor.format_creditors_table(
            data_map, 
            debtor_fio=owner_fio,
            debtor_inn=inn_number,
            debtor_snils=snils_number,
            debtor_address=адрес_прописки
        )

        # НОВОЕ: Рассчитываем общую сумму долга из таблиц кредиторов и налогов
        total_debt = Decimal(0)

        # Суммируем долги из таблицы кредиторов (credits)
        for credit in creditors_table_data.get("credits", []):
            # Берем "Задолженность_в_том_числе" (текущая задолженность)
            debt_str = credit.get("Задолженность_в_том_числе", "0")
            debt_amount = DocumentProcessor.parse_decimal(debt_str) or Decimal(0)
            total_debt += debt_amount

            # Добавляем штрафы и пени
            penalties_str = credit.get("Штрафы_пени_и_другое", "0")
            penalties_amount = DocumentProcessor.parse_decimal(penalties_str) or Decimal(0)
            total_debt += penalties_amount

        # Суммируем долги из таблицы налогов (taxes)
        for tax in creditors_table_data.get("taxes", []):
            # Берем сумму обязательного платежа
            tax_str = tax.get("Сумма_обяз_платежа", "0")
            tax_amount = DocumentProcessor.parse_decimal(tax_str) or Decimal(0)
            total_debt += tax_amount

            # Добавляем штрафы и пени по налогам
            tax_penalties_str = tax.get("Штрафы_пени_и_другое_обяз_платежа", "0")
            tax_penalties_amount = DocumentProcessor.parse_decimal(tax_penalties_str) or Decimal(0)
            total_debt += tax_penalties_amount

        # === ПАСПОРТНЫЕ ДАННЫЕ (с fallback на ОКБ) ===
        # Приоритет: паспорт > ОКБ
        series = passport.get("Серия") if passport else ""
        number = passport.get("Номер") if passport else ""
        
        # Если нет в паспорте, берем из ОКБ
        if not series and credit_history:
            series = credit_history.get("Серия_паспорта", "") or ""
        if not number and credit_history:
            number = credit_history.get("Номер_паспорта", "") or ""
        
        if series and number:
            series_number = f"{series} {number}"
        else:
            series_number = str(series or number or "")

        # Форматирование общей суммы долга прописью
        debt_formatted = ""
        if total_debt is not None and total_debt > 0:
            debt_formatted = DocumentProcessor.number_to_words_rubles(total_debt)

        # Проверка семейного положения и детей
        marital_children_text = DocumentProcessor.check_marital_and_children_status(passport, data_map)

        # Фамилия и инициалы - ВАЖНО: Делаем это ДО создания текстов с местоимениями
        fio_initials = passport.get("Фамилия_инициалы", "") if passport else ""
        fio_initials_rp = passport.get("Фамилия_инициалы_рп", "") if passport else ""

        # Если не заполнены в паспорте, используем функции склонения
        full_name = passport.get("ФИО", "") if passport else ""
        if not fio_initials_rp and full_name:
            fio_initials_rp = DocumentProcessor.convert_to_genitive_initials(full_name)

        # Дательный падеж (кому?) - инициалы
        fio_initials_dp = DocumentProcessor.convert_to_dative_initials(full_name)

        # НОВОЕ: Полные ФИО в разных падежах (без инициалов)
        fio_full_rp = DocumentProcessor.convert_to_genitive_full(full_name)  # Кузьмича Николая Павловича
        fio_full_dp = DocumentProcessor.convert_to_dative_full(full_name)    # Кузьмичу Николаю Павловичу
        fio_full_vp = DocumentProcessor.convert_to_accusative_full(full_name) # Кузьмича Николая Павловича

        # Разбиваем ФИО на отдельные компоненты
        fio_parts = full_name.split() if full_name else []
        familia = fio_parts[0] if len(fio_parts) > 0 else ""
        imya = fio_parts[1] if len(fio_parts) > 1 else ""
        otchestvo = fio_parts[2] if len(fio_parts) > 2 else ""

        # Определяем пол
        gender = DocumentProcessor.detect_gender(full_name)

        # Местоимения в зависимости от пола
        pronoun_accusative = DocumentProcessor.get_gender_pronoun(gender, "accusative")  # его/её
        pronoun_genitive = DocumentProcessor.get_gender_pronoun(gender, "genitive")  # него/неё
        pronoun_dative = DocumentProcessor.get_gender_pronoun(gender, "dative")  # ему/ей

        # Административная ответственность (по умолчанию нет)
        admin_responsibility = "Должник не привлекался к административной ответственности за мелкое хищение, умышленное уничтожение или повреждение имущества, неправомерные действия при банкротстве, фиктивное или преднамеренное банкротство."

        # Уголовная ответственность (по умолчанию нет) - используем правильное местоимение (родительный падеж)
        criminal_text = f"В отношении должника не имеется сведений об уголовных и административных делах в отношении {pronoun_genitive}, а также о наличии неснятой или непогашенной судимости."

        # Парсим адрес прописки на компоненты через GPT
        адрес_прописки = passport.get("Прописка", "") if passport else ""
        if openai_client and адрес_прописки:
            print(f"      Разбор адреса через GPT...")
            адрес_части = DocumentProcessor.parse_address_with_gpt(адрес_прописки, openai_client)
        else:
            адрес_части = DocumentProcessor.parse_address(адрес_прописки)

        # Получаем текущую дату по Екатеринбургскому времени
        date_components = DocumentProcessor.get_yekaterinburg_date()

        context: Dict[str, str] = {
            # Основные данные
            "ФИО": full_name,
            "Фамилия": familia,
            "Имя": imya,
            "Отчество": otchestvo,

            # Дата подачи заявления (по Екатеринбургскому времени)
            "АДень": date_components["АДень"],
            "АМесяц": date_components["АМесяц"],
            "АГод": date_components["АГод"],
            "ААГод": date_components["ААГод"],

            # С инициалами (Иванова И.И.)
            "Фамилия_инициалы": fio_initials,
            "Фамилия_инициалы_рп": fio_initials_rp,  # родительный падеж (кого? - Иванова И.И.)
            "Фамилия_инициалы_дп": fio_initials_dp,  # дательный падеж (кому? - Иванову И.И.)

            # НОВОЕ: Полные ФИО без инициалов
            "ФИО_рп": fio_full_rp,  # родительный падеж (кого? - Иванова Ивана Ивановича)
            "ФИО_дп": fio_full_dp,  # дательный падеж (кому? - Иванову Ивану Ивановичу)
            "ФИО_вп": fio_full_vp,  # винительный падеж (кого? - Иванова Ивана Ивановича)

            "Пол": gender,  # "м" или "ж"
            "его_её": pronoun_accusative,  # "его" или "её" (винительный)
            "него_неё": pronoun_genitive,  # "него" или "неё" (родительный)
            "ему_ей": pronoun_dative,  # "ему" или "ей" (дательный)
            "Адрес_регистрации": адрес_прописки,
            # Дата рождения: приоритет паспорт > ОКБ
            "Дата_рождения": (passport.get("Дата_рождения", "") if passport else "") or (credit_history.get("Дата_рождения", "") if credit_history else ""),
            # Место рождения: приоритет паспорт > ОКБ
            "Место_рождения": (passport.get("Место_рождения", "") if passport else "") or (credit_history.get("Место_рождения", "") if credit_history else ""),

            # Арбитражный суд (определяется по адресу регистрации)
            "Арбитражный_суд": DocumentProcessor.get_arbitration_court(адрес_прописки),

            # Компоненты адреса прописки
            "Субъект_прописка": адрес_части.get("субъект", ""),
            "Район_прописка": адрес_части.get("район", ""),
            "Города_прописка": адрес_части.get("город", ""),
            "Населенный_пункт_прописка": адрес_части.get("населенный_пункт", ""),
            "Улица_прописка": адрес_части.get("улица", ""),
            "Номер_дома_прописка": адрес_части.get("дом", ""),
            "Номер_корпуса_прописка": адрес_части.get("корпус", ""),
            "Номер_квартиры_прописка": адрес_части.get("квартира", ""),

            # Паспорт (с fallback на ОКБ)
            "Серия_и_номер_пас": series_number,
            # Кем выдан: приоритет паспорт > ОКБ
            "КемВыданПаспорт": (passport.get("Кем_выдан", "") if passport else "") or (credit_history.get("Кем_выдан", "") if credit_history else ""),
            "Кем_выдан_пас": (passport.get("Кем_выдан", "") if passport else "") or (credit_history.get("Кем_выдан", "") if credit_history else ""),
            # Дата выдачи: приоритет паспорт > ОКБ
            "Когда_выдан_пас": (passport.get("Дата_выдачи", "") if passport else "") or (credit_history.get("Дата_выдачи", "") if credit_history else ""),
            "Когда_выда_пас": (passport.get("Дата_выдачи", "") if passport else "") or (credit_history.get("Дата_выдачи", "") if credit_history else ""),
            # Код подразделения: приоритет паспорт > ОКБ
            "Код_подразделения": (passport.get("Код_подразделения", "") if passport else "") or (credit_history.get("Код_подразделения", "") if credit_history else ""),

            # Документы
            "Номер_снилс": snils_number,
            "Номер_инн": inn_number,
            "Снилс": snils_number,  # Алиас для шаблонов
            "ИНН": inn_number,       # Алиас для шаблонов
            "Инн": inn_number,       # Альтернативный алиас

            # Работа
            "Место_работы": DocumentProcessor.extract_employers(labour) if labour else "",
            "Текущ_место_работы": DocumentProcessor.extract_current_job(labour) if labour else "Нет",

            # Супруг (заинтересованное лицо)
            "Заинтересованное_лицо": DocumentProcessor.format_interested_party(passport_spouse, inn_spouse, snils_spouse),

            # Дети и брак
            "Женатзамужем": DocumentProcessor.get_marital_status_key(passport, data_map),
            "Несовершеннолетние_дети": DocumentProcessor.determine_children_status(
                passport.get("Дети") if passport else None,
                data_map
            ),

            # Финансы
            "Общая_сумма_долга": debt_formatted,
            "Средняя_зп_за_месяц": DocumentProcessor.format_decimal(average_income) if average_income else "",
            "Количество_счетов_в_банках": str(accounts_count) if accounts_count is not None else "0",
            "Количество_счетов_текстом": DocumentProcessor.format_count_with_word(
                accounts_count if accounts_count is not None else 0,
                "счет", "счета", "счетов"
            ),

            # Имущество
            "Недвижимое_имущество": real_estate_detailed,
            "Движемое_имущество": DocumentProcessor.format_movable_property(data_map.get("гибдд", [])),
            "Акции_и_иное_участие_в_ком_организациях": DocumentProcessor.format_shares(data_map.get("учредитель", [])),
            "Ценные_бумаги": DocumentProcessor.format_securities(data_map.get("ценные_бумаги", [])),
            "Наличные_и_иное_ценное_имущество": DocumentProcessor.format_cash_valuables(data_map.get("ценное_имущество", [])),
            "имущественные_права": DocumentProcessor.format_property_rights(data_map.get("имущественные_права", [])),

            # Доходы
            "Иные_доходы": DocumentProcessor.format_other_income(
                data_map.get("пенсии", []),
                data_map.get("выплаты", [])
            ),

            # Текстовые блоки
            "Нету_детей_и_брака": marital_children_text,
            "Детей_и_брак": marital_children_text,  # Альтернативное имя ключа для совместимости
            "Административная_ответственность": admin_responsibility,
            "Уголовная_ответственность": criminal_text,

            # Приложения (формируем из списка файлов)
            "Приложения": DocumentProcessor.format_attachments(pdf_paths or []),
        }

        # Добавляем данные таблицы кредиторов
        context.update(creditors_table_data)

        # Добавляем данные для описи имущества
        bank_accounts_data = DocumentProcessor.format_bank_accounts_table(data_map.get("счета", []))
        context.update(bank_accounts_data)

        realty_data = DocumentProcessor.format_realty_table(data_map.get("егрн_выписка", []), owner_fio=owner_fio)
        context.update(realty_data)

        vehicles_data = DocumentProcessor.format_vehicles_table(data_map.get("гибдд", []))
        context.update(vehicles_data)

        # Фоллбэки для пустых значений
        fallbacks = {
            "Адрес_регистрации": "не указано",
            "Дата_рождения": "не указано",
            "Место_рождения": "не указано",
            "Серия_и_номер_пас": "не указано",
            "КемВыданПаспорт": "не указано",
            "Кем_выдан_пас": "не указано",
            "Когда_выдан_пас": "не указано",
            "Когда_выда_пас": "не указано",
            "Код_подразделения": "не указано",
            "Номер_снилс": "не указано",
            "Номер_инн": "не указано",
            "Место_работы": "не указано",
            "Средняя_зп_за_месяц": "не указано",
        }

        for key, fallback in fallbacks.items():
            if not context.get(key):
                context[key] = fallback

        # ВАЖНО: Собираем все сделки из разных документов и добавляем обратно в data_map
        # Это нужно для API endpoint /api/debtors/<id>/deals
        all_deals = DocumentProcessor.extract_deals_from_all_documents(data_map, owner_fio)
        if all_deals:
            # Добавляем собранные сделки в data_map, чтобы они сохранились в raw_data
            data_map["сделки"] = all_deals

        # КРИТИЧЕСКИ ВАЖНО: Заменяем все None на пустые строки во всём контексте
        # Это предотвращает появление "None" в Word документах
        context = DocumentProcessor.replace_none_with_empty(context)

        return context

    @staticmethod
    def replace_none_with_empty(obj):
        """Рекурсивно заменяет все None на пустые строки в словарях и списках.

        Args:
            obj: Объект для обработки (dict, list или любой другой тип)

        Returns:
            Обработанный объект с заменёнными None
        """
        if isinstance(obj, dict):
            return {key: DocumentProcessor.replace_none_with_empty(value) for key, value in obj.items()}
        elif isinstance(obj, list):
            return [DocumentProcessor.replace_none_with_empty(item) for item in obj]
        elif obj is None:
            return ""
        else:
            return obj

    @staticmethod
    def merge_table_cells_for_creditors(doc_path: Path, credits_data: List[Dict]) -> None:
        """Объединяет ячейки в таблице кредиторов для одного кредитора с несколькими договорами."""
        from docx import Document
        from docx.oxml import parse_xml
        from docx.oxml.ns import nsdecls
        
        doc = Document(doc_path)
        
        # Ищем таблицу кредиторов — 9 столбцов и есть "Кредитор" в первых 4 строках
        target_table = None
        for table_idx, table in enumerate(doc.tables):
            if len(table.rows) > 2 and len(table.columns) == 9:
                # Проверяем первые 4 строки на наличие "Кредитор"
                found_kreditor = False
                for row_idx in range(min(4, len(table.rows))):
                    row_text = ' '.join(cell.text for cell in table.rows[row_idx].cells)
                    if "Кредитор" in row_text:
                        found_kreditor = True
                        break
                
                if found_kreditor:
                    target_table = table
                    print(f"      [MERGE] Найдена таблица кредиторов: таблица #{table_idx}, строк: {len(table.rows)}, столбцов: {len(table.columns)}")
                    break
        
        if not target_table:
            print(f"      [MERGE] Таблица кредиторов не найдена")
            return
        
        # Находим первую строку данных (пропускаем заголовки)
        data_start_row = 0
        data_end_row = len(target_table.rows) - 1
        
        for row_idx, row in enumerate(target_table.rows):
            # Ищем первую строку где есть № п/п но это не заголовок
            if row_idx > 0 and row.cells[0].text.strip() and row.cells[0].text.strip() != '№ п/п' and row.cells[0].text.strip() != '№\nп/п':
                # Проверяем, есть ли "1.1" или похожее в столбце 0
                if '.' in row.cells[0].text or row.cells[0].text.strip() == '':
                    data_start_row = row_idx
                    break
        
        # Находим конец раздела кредиторов (до начала "Обязательные платежи")
        for row_idx in range(data_start_row, len(target_table.rows)):
            row_text = ' '.join(cell.text for cell in target_table.rows[row_idx].cells).lower()
            if 'обязательные платежи' in row_text or 'налог' in row_text:
                data_end_row = row_idx - 1
                break
        
        if data_start_row == 0:
            return
        
        # Строим группы: для каждого кредитора находим строки в таблице с его договорами
        # Группируем по № п/п в столбце 0 (например "1.1", "1.2" и т.д.)
        creditor_groups = []  # [(first_row, last_row), ...]
        current_pp = None
        first_row_of_group = None
        
        print(f"      [MERGE] Анализ строк от {data_start_row} до {data_end_row}...")
        
        for row_idx in range(data_start_row, data_end_row + 1):
            pp_text = target_table.rows[row_idx].cells[0].text.strip()
            print(f"      [MERGE]   Строка {row_idx}: № п/п = '{pp_text}'")
            
            # Если это новый № п/п (не пустой)
            if pp_text and '.' in pp_text:
                # Закрываем предыдущую группу
                if current_pp is not None and first_row_of_group is not None:
                    if row_idx - first_row_of_group > 1:  # Группа больше 1 строки
                        creditor_groups.append((first_row_of_group, row_idx - 1))
                        print(f"      [MERGE]     → Сохранена группа '{current_pp}': строки {first_row_of_group} - {row_idx - 1}")
                
                # Начинаем новую группу
                current_pp = pp_text
                first_row_of_group = row_idx
            
            # Если это пустой № п/п, продолжаем текущую группу
            elif not pp_text and current_pp is not None:
                pass  # Группа продолжается
        
        # Закрываем последнюю группу
        if current_pp is not None and first_row_of_group is not None:
            if data_end_row - first_row_of_group >= 1:  # Группа больше 1 строки
                creditor_groups.append((first_row_of_group, data_end_row))
                print(f"      [MERGE]     → Сохранена последняя группа '{current_pp}': строки {first_row_of_group} - {data_end_row}")
        
        print(f"      [MERGE] Найдено групп для объединения: {len(creditor_groups)}")
        
        # Объединяем ячейки для каждой группы
        # Столбцы для объединения: 0 (№ п/п), 2 (Кредитор), 3-4 (Адрес - два столбца)
        columns_to_merge = [0, 2, 3, 4]
        
        for first_row_idx, last_row_idx in creditor_groups:
            print(f"      [MERGE] Объединяем группу: строки {first_row_idx} - {last_row_idx}")
            
            for col_idx in columns_to_merge:
                if col_idx >= len(target_table.columns):
                    continue
                
                try:
                    # Устанавливаем vMerge для первой ячейки
                    first_cell = target_table.rows[first_row_idx].cells[col_idx]
                    first_cell_xml = first_cell._element.get_or_add_tcPr()
                    vmerge = parse_xml(f'<w:vMerge {nsdecls("w")} w:val="restart"/>')
                    first_cell_xml.append(vmerge)
                    
                    # Устанавливаем vMerge для остальных ячеек группы
                    for row_idx in range(first_row_idx + 1, last_row_idx + 1):
                        if row_idx >= len(target_table.rows):
                            break
                        cell = target_table.rows[row_idx].cells[col_idx]
                        cell_xml = cell._element.get_or_add_tcPr()
                        vmerge_continue = parse_xml(f'<w:vMerge {nsdecls("w")}/>')
                        cell_xml.append(vmerge_continue)
                except Exception as e:
                    print(f"          [DEBUG] Ошибка объединения столбца {col_idx}: {e}")
        
        doc.save(doc_path)

    @staticmethod
    def fill_docx_template_dynamic(template_path: Path, output_path: Path, context: Dict[str, Any]) -> None:
        """Заполняет Word шаблон с поддержкой динамических таблиц (Jinja2)."""
        doc = DocxTemplate(template_path)

        # Рендерим шаблон с контекстом
        doc.render(context)

        # Создаем папку если нужно
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Сохраняем результат
        doc.save(output_path)
        
        # Если это список кредиторов, объединяем ячейки
        if "Список кредиторов" in str(template_path) and "credits" in context:
            try:
                DocumentProcessor.merge_table_cells_for_creditors(output_path, context["credits"])
            except Exception as e:
                print(f"      [WARNING] Не удалось объединить ячейки: {e}")

    @staticmethod
    def fill_docx_template(template_path: Path, output_path: Path, context: Dict[str, str]) -> None:
        """Старая функция для простых шаблонов без динамических таблиц."""
        # Фильтруем списки из контекста (они для динамических шаблонов)
        filtered_context = {
            k: v for k, v in context.items() 
            if not isinstance(v, (list, dict)) or k in []
        }

        with zipfile.ZipFile(template_path, "r") as template_zip:
            xml = template_zip.read("word/document.xml").decode("utf-8")

        # Нормализуем XML: убираем разрывы внутри фигурных скобок {{...}}
        # Word может разбить {{Ключ}} на несколько тегов, что ломает замену
        import re

        # Паттерн для поиска {{ключ}}, разбитых на части
        # Находим {, затем любые символы и теги до }
        pattern = r'\{\{([^}]*)\}\}'

        def normalize_key(match):
            # Извлекаем всё между {{ и }}
            inner = match.group(1)
            # Удаляем все XML теги внутри
            clean = re.sub(r'<[^>]+>', '', inner)
            # Убираем неразрывные пробелы и лишние пробелы по бокам
            clean = clean.replace('\u00A0', ' ').strip()
            # Возвращаем нормализованный ключ
            return f"{{{{{clean}}}}}"

        xml = re.sub(pattern, normalize_key, xml, flags=re.DOTALL)

        # Теперь делаем замену (используем отфильтрованный контекст)
        for key, value in filtered_context.items():
            # Приводим значение к строке, чтобы корректно вставлять в XML
            replacement = str(value) if value is not None else ""
            xml = xml.replace(f"{{{{{key}}}}}", replacement)

        # Заменяем {{LINE_BREAK}} на простой перенос строки в Word
        # Используем <w:br/> для переноса строки внутри одного параграфа
        # Это сохраняет ВСЕ форматирование параграфа (шрифт, размер, интервалы, отступы)
        line_break_xml = '</w:t><w:br/><w:t xml:space="preserve">'
        xml = xml.replace("{{LINE_BREAK}}", line_break_xml)

        output_path.parent.mkdir(parents=True, exist_ok=True)
        with zipfile.ZipFile(template_path, "r") as template_zip, zipfile.ZipFile(
            output_path, "w"
        ) as output_zip:
            for item in template_zip.infolist():
                data = template_zip.read(item.filename)
                if item.filename == "word/document.xml":
                    data = xml.encode("utf-8")
                output_zip.writestr(item, data)

    @staticmethod
    def fill_template(template_path: Path, output_path: Path, context: Dict[str, Any]) -> None:
        """Compatibility wrapper used by `app.py`.

        Tries to render the template as a dynamic Jinja2/DocxTemplate first,
        and falls back to the older XML-replacement implementation if needed.
        """
        # Ensure context has no None values to avoid literal 'None' in documents
        safe_context = DocumentProcessor.replace_none_with_empty(context)

        # First try dynamic rendering
        try:
            DocumentProcessor.fill_docx_template_dynamic(template_path, output_path, safe_context)
            return
        except Exception as e_dynamic:
            # Fallback to simple XML replacement
            try:
                print(f"      INFO - Dynamic render failed for {template_path.name}: {e_dynamic}. Falling back to simple replacement.")
                DocumentProcessor.fill_docx_template(template_path, output_path, safe_context)
                return
            except Exception as e_simple:
                # Re-raise a combined error to help debugging
                raise RuntimeError(f"Both dynamic and simple template rendering failed for {template_path}: dynamic_error={e_dynamic}, simple_error={e_simple}")

    @staticmethod
    def render_bankruptcy_application(context: Dict[str, str]) -> Optional[Path]:
        if not TEMPLATE_DOCX.exists():
            return None
        # Создаем папку для результатов
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        # Сохраняем в папку resultdoc
        output_name = f"{TEMPLATE_DOCX.stem}{FILLED_TEMPLATE_SUFFIX}{TEMPLATE_DOCX.suffix}"
        output_path = OUTPUT_DIR / output_name
        DocumentProcessor.fill_docx_template(TEMPLATE_DOCX, output_path, context)
        return output_path

    @staticmethod
    def generate_all_documents(context: Dict[str, str], debtor_id: Optional[str] = None, lawyer: Optional[str] = None) -> List[Path]:
        """Generate all bankruptcy document templates and return list of paths.
        
        Args:
            context: Template context data
            debtor_id: Unique debtor identifier for file separation
        """
        # Если указан debtor_id, создаем отдельную папку для должника
        if debtor_id:
            output_dir = OUTPUT_DIR / debtor_id
        else:
            output_dir = OUTPUT_DIR
            
        output_dir.mkdir(parents=True, exist_ok=True)
        generated_files = []

        templates = [
            {
                "name": "Заявление о банкротстве",
                "template": None,
                "output": output_dir / "Заявление на банкротство (заполненное).docx",
                "dynamic": False
            },
            {
                "name": "Ходатайство об отсрочке",
                "template": Path("templ") / "Ходатайство об отсрочке.docx",
                "output": output_dir / "Ходатайство об отсрочке (заполненное).docx",
                "dynamic": False
            },
            {
                "name": "Ходатайство о реализации имущества",
                "template": Path("templ") / "Ходатайство о реализации имущества.docx",
                "output": output_dir / "Ходатайство о реализации имущества (заполненное).docx",
                "dynamic": False
            },
            {
                "name": "Список кредиторов и должников",
                "template": Path("templ") / "Список кредиторов и должников.docx",
                "output": output_dir / "Список кредиторов и должников (заполненное).docx",
                "dynamic": True
            },
            {
                "name": "Опись имущества",
                "template": Path("templ") / "Опись имущества.docx",
                "output": output_dir / "Опись имущества (заполненное).docx",
                "dynamic": True
            },
        ]
        # Map template names to possible filenames (same order)
        template_filenames = [
            "Заявление на банкротство.docx",
            "Ходатайство об отсрочке.docx",
            "Ходатайство о реализации имущества.docx",
            "Список кредиторов и должников.docx",
            "Опись имущества.docx",
        ]

        for idx, item in enumerate(templates):
            # Resolve template path: prefer templ/<lawyer>/<filename> if lawyer provided
            filename = template_filenames[idx]
            candidate_paths = []
            if lawyer:
                candidate_paths.append(Path("templ") / lawyer / filename)
            candidate_paths.append(Path("templ") / filename)

            template_path = None
            for p in candidate_paths:
                if p.exists():
                    template_path = p
                    break
            output_path = item["output"]
            is_dynamic = item.get("dynamic", False)

            if not template_path or not template_path.exists():
                # No template found for this item (neither lawyer-specific nor default)
                # Skip generating this document
                # print debug info for visibility
                print(f"      INFO - No template found for '{item['name']}' (checked: {[str(p) for p in candidate_paths]})")
                continue
            else:
                print(f"      INFO - Using template for '{item['name']}': {template_path}")

            try:
                # Use compatibility wrapper that first tries DocxTemplate (dynamic rendering)
                # and falls back to simple XML replacement. This handles placeholders
                # that Word splits across multiple runs.
                DocumentProcessor.fill_template(template_path, output_path, context)

                generated_files.append(output_path)
            except PermissionError:
                print(f"      WARNING - File is open: {output_path.name}")
                continue
            except Exception as e:
                print(f"      ERROR generating {item['name']}: {e}")
                continue

        return generated_files

    @staticmethod
    def process_pdf_with_gpt(pdf_path: Path, prompt: str) -> tuple[str, Optional[int]]:
        """Process PDF file directly with GPT-4o (for ОКБ reports).
        
        Returns:
            Tuple of (response_text, error_code) where error_code is HTTP status for errors or None for success
        """
        try:
            # Загружаем PDF файл в OpenAI с purpose="vision"
            uploaded_file = client.files.create(
                file=open(pdf_path, "rb"),
                purpose="vision"
            )
            
            # Отправляем промпт с прикреплённым файлом через SDK
            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "input_file",
                                "input_file_id": uploaded_file.id
                            },
                            {
                                "type": "text",
                                "text": prompt
                            }
                        ]
                    }
                ],
                max_completion_tokens=16000
            )
            
            # Удаляем загруженный файл
            try:
                client.files.delete(uploaded_file.id)
            except:
                pass
            
            return response.choices[0].message.content.strip(), None
        except Exception as exc:
            error_code = None
            error_str = str(exc)
            if "400" in error_str or "Bad Request" in error_str:
                error_code = 400
            elif "500" in error_str or "Internal Server Error" in error_str:
                error_code = 500
            elif "429" in error_str or "Too Many Requests" in error_str:
                error_code = 429
            return f"[Ошибка обработки: {exc}]", error_code

    @staticmethod
    def process_images_with_gpt(image_paths: List[str], prompt: str) -> tuple[str, Optional[int]]:
        """Process multiple images with GPT-5 Vision in one request.
        
        Returns:
            Tuple of (response_text, error_code) where error_code is HTTP status for errors or None for success
        """
        try:
            # Prepare content with all images
            content = [{"type": "text", "text": prompt}]

            for image_path in image_paths:
                base64_image = DocumentProcessor.encode_image_to_base64(image_path)
                content.append({
                    "type": "image_url",
                    "image_url": {
                        "url": f"data:image/jpeg;base64,{base64_image}"
                    }
                })

            response = client.chat.completions.create(
                model=GPT_MODEL,
                messages=[
                    {
                        "role": "user",
                        "content": content
                    }
                ],
                max_completion_tokens=16000,  # Максимальное количество токенов для ответа
            )
            return response.choices[0].message.content.strip(), None
        except Exception as exc:  # noqa: BLE001
            # Пытаемся извлечь HTTP код ошибки
            error_code = None
            error_str = str(exc)
            if "400" in error_str or "Bad Request" in error_str:
                error_code = 400
            elif "500" in error_str or "Internal Server Error" in error_str:
                error_code = 500
            elif "429" in error_str or "Too Many Requests" in error_str:
                error_code = 429
            return f"[Ошибка обработки: {exc}]", error_code

    @staticmethod
    def process_pdf_with_assistants(pdf_path: Path, prompt: str) -> tuple[Dict[str, Any], Optional[str]]:
        """Process PDF directly using OpenAI Assistants API (for credit reports)."""
        try:
            # Upload PDF file
            print(f"      Загрузка PDF в OpenAI...", end=" ", flush=True)
            with open(pdf_path, "rb") as f:
                uploaded_file = client.files.create(file=f, purpose="assistants")
            print(f"OK")

            # Create assistant with file_search
            print(f"      Создание ассистента...", end=" ", flush=True)
            assistant = client.beta.assistants.create(
                model="gpt-4o-mini",  # Самая мощная доступная модель для Assistants API
                tools=[{"type": "file_search"}],
                temperature=0,  # Максимальная точность
            )
            print(f"OK")

            # Create thread with attached PDF
            print(f"      Анализ документа...", end=" ", flush=True)
            thread = client.beta.threads.create(
                messages=[{
                    "role": "user",
                    "content": prompt,
                    "attachments": [{
                        "file_id": uploaded_file.id,
                        "tools": [{"type": "file_search"}]
                    }]
                }]
            )

            # Run assistant
            run = client.beta.threads.runs.create(
                thread_id=thread.id,
                assistant_id=assistant.id
            )

            # Wait for completion
            max_wait = 120  # 2 minutes timeout
            elapsed = 0
            while run.status in ["queued", "in_progress"]:
                time.sleep(2)
                elapsed += 2
                run = client.beta.threads.runs.retrieve(
                    thread_id=thread.id,
                    run_id=run.id
                )
                if elapsed >= max_wait:
                    raise TimeoutError("Assistants API timeout")

            print(f"OK")

            # Check for errors
            if run.status == "failed":
                error_msg = f"Assistant failed: {run.last_error.message if run.last_error else 'Unknown error'}"
                return {}, error_msg

            # Get response
            messages = client.beta.threads.messages.list(thread_id=thread.id)
            response_text = messages.data[0].content[0].text.value

            # Parse JSON
            cleaned = DocumentProcessor.clean_json_response(response_text)
            try:
                data = json.loads(cleaned)
                error = None
            except json.JSONDecodeError as e:
                # Try to extract JSON from markdown or text
                import re
                json_match = re.search(r'\{.*\}', cleaned, re.DOTALL)
                if json_match:
                    try:
                        data = json.loads(json_match.group(0))
                        error = None
                    except:
                        data = {"raw_response": response_text}
                        error = f"JSON decode error: {str(e)}"
                else:
                    data = {"raw_response": response_text}
                    error = f"JSON decode error: {str(e)}"

            # Cleanup
            try:
                client.beta.assistants.delete(assistant.id)
                client.files.delete(uploaded_file.id)
            except:
                pass

            return data, error

        except Exception as exc:
            return {"error": str(exc)}, str(exc)

    def process_pdf(self, pdf_path: Path) -> DocumentOutput:
        """Process PDF document with all pages at once using GPT-5 Vision."""
        pdf_path = pdf_path.resolve()

        # Сначала пробуем определить тип по имени файла
        doc_type, base_prompt = self.detect_document_type(pdf_path.name)

        print(f"   > {pdf_path.name}")
        print(f"      Тип: {doc_type}")

        start_time = time.time()

        # ===  СПЕЦИАЛЬНАЯ ОБРАБОТКА ДЛЯ КРЕДИТНЫХ ОТЧЕТОВ ===
        if doc_type in ["отчет_окб", "отчет_бки", "отчет_нбки"]:
            print(f"      [CREDIT] Обработка кредитного отчета")
            
            # Конвертируем в изображения
            print(f"      Конвертация PDF в изображения...", end=" ", flush=True)
            pdf = pdfium.PdfDocument(str(pdf_path))
            total_pages = len(pdf)
            
            # Для БКИ ограничиваем 25 страницами, для ОКБ - все страницы
            if doc_type == "отчет_бки":
                max_pages = min(25, total_pages)
            else:
                max_pages = total_pages
                
            pages = []
            for i in range(max_pages):
                page = pdf[i]
                bitmap = page.render(scale=2.5)
                pil_image = bitmap.to_pil()
                pages.append(pil_image)
            print(f"OK ({len(pages)} из {total_pages} стр.)")

            # Сохраняем страницы
            print(f"      Сохранение страниц...", end=" ", flush=True)
            page_images = []
            for page in pages:
                with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as tmp_file:
                    tmp_path = tmp_file.name
                    page.save(tmp_path, 'JPEG', quality=95, optimize=True)
                    page_images.append(tmp_path)
            print("OK")

            # Определяем batch size и overlap в зависимости от типа отчета
            if doc_type == "отчет_нбки":
                BATCH_SIZE = 5  # НБКИ: маленькие батчи по 5 страниц
                OVERLAP_PAGES = 5  # НБКИ: overlap 5 страниц
            elif doc_type == "отчет_окб":
                BATCH_SIZE = 50  # ОКБ: большие батчи
                OVERLAP_PAGES = 3  # ОКБ: overlap 3 страницы
            else:  # БКИ
                BATCH_SIZE = 50
                OVERLAP_PAGES = 0  # БКИ: без overlap
            
            use_batch = len(pages) > BATCH_SIZE
            batch_size = BATCH_SIZE  # Может уменьшаться при ошибках

            extracted_data = {}
            error = None

            if use_batch:
                print(f"      [BATCH] Документ большой ({len(pages)} стр.), обработка батчами по {batch_size} стр. (overlap: {OVERLAP_PAGES})")
                
                all_credits = []
                batch_num = 0
                retry_smaller = False
                
                for start_idx in range(0, len(page_images), batch_size):
                    end_idx = min(start_idx + batch_size, len(page_images))
                    
                    # Добавляем overlap с предыдущим батчом (кроме первого)
                    if OVERLAP_PAGES > 0 and start_idx > 0:
                        overlap_start = max(0, start_idx - OVERLAP_PAGES)
                        batch_pages = page_images[overlap_start:end_idx]
                        actual_start = overlap_start + 1  # Для отображения в логе
                    else:
                        batch_pages = page_images[start_idx:end_idx]
                        actual_start = start_idx + 1
                    
                    batch_num += 1
                    
                    # Специальные промпты для разных типов отчетов
                    if doc_type == "отчет_окб":
                        # Добавляем информацию об overlap в промпт
                        overlap_info = ""
                        if start_idx > 0:
                            overlap_info = f"""
КОНТЕКСТ: Первые {OVERLAP_PAGES} страницы - это КОНТЕКСТ из предыдущего батча для связности.
НЕ извлекай данные повторно из этих {OVERLAP_PAGES} страниц!
Используй их только для понимания контекста, если таблица или раздел начинается на них.
Анализируй и извлекай данные ТОЛЬКО из НОВЫХ страниц (начиная со страницы {OVERLAP_PAGES + 1}).
"""
                        
                        batch_prompt = base_prompt + overlap_info + f"""

Найди таблицу "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ" или "АКТИВНЫЕ ДОГОВОРЫ".

Для КАЖДОЙ строки таблицы:
1. Название кредитора (например: МТС-БАНК ПАО)
2. Найди детальный раздел НИЖЕ с этим кредитором и извлеки:
   - "Дата совершения сделки" или "Дата возникновения обязательства"
   - "Сумма и валюта обязательства" (ОБЯЗАТЕЛЬНО! первоначальная сумма кредита)
   - В разделе "Сведения об источнике" ищи строку "ИНН и ОГРН (ОГРНИП)". Там будет текст вида: "ИНН³ 7744000912" и строкой ниже "ОГРН 1027739019142"
   - ИНН - это число из строки с пометкой "ИНН³" (10 цифр). ОБЯЗАТЕЛЬНО извлеки его!
   - ОГРН НЕ НУЖЕН (это 13 цифр)
   - Тип кредита/займа (из колонки "Вид обязательства" или аналогичной: Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, Необеспеченный кредит, и т.д.)
   - В таблице "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ" колонка "Общая задолженность":
     Возьми значение из колонки "Общая задолженность" = текущий долг

КРИТИЧЕСКИ ВАЖНО ПРО ДОЛГ В ОКБ:
- Используй ТОЛЬКО "Общая задолженность" из таблицы "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ"
- "Общая задолженность" УЖЕ ВКЛЮЧАЕТ просрочку, проценты и всё остальное!
- ИЛИ сложи "Основной долг" + "Проценты" + "Иное" из детального раздела НИЖЕ в таблице "Сведения о сумме задолженности"
- НЕ суммируй "Общая задолженность + Просроченная задолженность" в таблице ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ!
- Просто возьми значение "Общая задолженность" как есть

JSON:
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "ИНН_кредитора": "число из строки 'ИНН³' в разделе 'Сведения об источнике' (10 цифр, например: 7744000912)",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "ДД.ММ.ГГГГ",
      "Сумма_обязательства": "первоначальная сумма",
      "Сумма": "значение из 'Общая задолженность' (НЕ складывать!)"
    }}
  ]
}}"""
                    elif doc_type == "отчет_бки":
                        # Для БКИ - даты в основной таблице
                        batch_prompt = base_prompt + f"""

Найди таблицу "АКТИВНЫЕ ДОГОВОРЫ".

Для КАЖДОЙ строки таблицы извлеки:
- Кредитор (точное название из колонки)
- Дата начала договора (из колонки "Дата начала договора")
- Тип кредита/займа (из колонки "Вид обязательства" или аналогичной: Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, Необеспеченный кредит, и т.д.)
- Сумма обязательства по договору (ОБЯЗАТЕЛЬНО! из колонки "Сумма обязательства по договору" - первоначальная сумма кредита)
- Текущий долг = "Текущая задолженность" + "Текущая просрочка, сумма"

ВАЖНО: 
- "Сумма обязательства по договору" - это первоначальная сумма кредита, НЕ текущий долг!
- Поле в JSON ОБЯЗАТЕЛЬНО должно называться "Кредиты", НЕ "Договоры"!
- В БКИ отчёте НЕТ ИНН кредитора, поэтому НЕ извлекай его!

JSON (СТРОГО этот формат):
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "дата",
      "Сумма_обязательства": "первоначальная сумма из колонки",
      "Сумма": "текущая задолженность + просрочка"
    }}
  ]
}}"""
                    elif doc_type == "отчет_нбки":
                        # НБКИ промпт с информацией об overlap
                        overlap_info = ""
                        if start_idx > 0:
                            overlap_info = f"""
КОНТЕКСТ: Первые {OVERLAP_PAGES} страницы - это КОНТЕКСТ из предыдущего батча для связности.
НЕ извлекай данные повторно из этих {OVERLAP_PAGES} страниц!
Используй их только для понимания контекста, если раздел кредитора начинается на них.
Анализируй и извлекай данные ТОЛЬКО из НОВЫХ страниц (начиная со страницы {OVERLAP_PAGES + 1}).
"""
                        
                        batch_prompt = base_prompt + overlap_info + f"""

Найди раздел с заголовком "Обязательства и их исполнение" - там начинается список кредиторов.

Для КАЖДОГО кредитора:
1. Название банка/кредитора (заголовок раздела)
2. В таблице "Основные сведения об обязательстве":
   - Столбец "Сумма и валюта обязательства" = первоначальная сумма займа (Сумма_обязательства)
   - Столбец "Дата возникновения обязательства" = дата сделки (Дата_сделки)
   - Столбец "ОГРН/ИНН" - там два числа через пробел. ПЕРВОЕ (13 цифр) - это ОГРН, НЕ НУЖНО. ВТОРОЕ (10 цифр) - это ИНН кредитора, ОБЯЗАТЕЛЬНО извлеки!
   - Тип кредита/займа (из строки "Вид обязательства" или аналогичной: Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, и т.д.)
3. В таблице "Задолженность":
   - Найди САМУЮ ПОСЛЕДНЮЮ строку в таблице
   - Возьми значение из столбца "Сумма" (это текущий долг)
   - ИГНОРИРУЙ другие столбцы ("Сумма по осн.долгу", "Сумма по %%", и т.д.)

КРИТИЧЕСКИ ВАЖНО:
- Берем ТОЛЬКО последнюю строку таблицы "Задолженность"
- Берем ТОЛЬКО столбец "Сумма" из этой строки
- Это и есть текущий долг
- НЕ суммируем ничего, просто берем одно значение!
- В столбце "ОГРН/ИНН" берем ВТОРОЕ число (10 цифр) - это ИНН кредитора!

JSON (СТРОГО этот формат):
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "ИНН_кредитора": "ВТОРОЕ число из столбца ОГРН/ИНН (10 цифр)",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "ДД.ММ.ГГГГ",
      "Сумма_обязательства": "первоначальная сумма",
      "Сумма": "последняя строка таблицы Задолженность, столбец Сумма"
    }}
  ]
}}"""

                    try:
                        # Выводим информацию о батче с учётом overlap
                        if OVERLAP_PAGES > 0 and start_idx > 0:
                            print(f"         Батч {batch_num} ({actual_start}-{end_idx}, overlap: {OVERLAP_PAGES} стр.)...", end=" ", flush=True)
                        else:
                            print(f"         Батч {batch_num} ({actual_start}-{end_idx})...", end=" ", flush=True)
                        
                        response_text, error_code = self.process_images_with_gpt(batch_pages, batch_prompt)
                        
                        # Проверяем ошибки 400/500 - запрос слишком большой
                        if error_code in [400, 500]:
                            print(f"ERROR {error_code}")
                            if batch_size > 30:
                                # Уменьшаем размер батча и повторяем этот батч
                                new_batch_size = batch_size // 2
                                print(f"         [AUTO] Уменьшаю размер батча до {new_batch_size} стр. и повторяю...")
                                batch_size = new_batch_size
                                retry_smaller = True
                                # Откатываемся назад, чтобы обработать этот батч заново
                                start_idx -= batch_size
                                continue
                            else:
                                # Батч уже слишком маленький - пропускаем
                                print(f"         [SKIP] Батч слишком маленький, пропускаем")
                                if not error:
                                    error = f"Batch {batch_num} failed with error {error_code}"
                                continue
                        
                        cleaned = self.clean_json_response(response_text)
                        
                        # Проверка: если GPT вернул текстовое сообщение вместо JSON (нехватка контекста)
                        if cleaned and ("нужна дополнительная" in cleaned.lower() or "пришлите" in cleaned.lower() or "не могу" in cleaned.lower()):
                            print(f"SKIP (недостаточно контекста в батче)")
                            continue
                        
                        try:
                            batch_data = json.loads(cleaned) if cleaned else {}
                            
                            # FALLBACK: если GPT вернул "Договоры" вместо "Кредиты"
                            if "Договоры" in batch_data and "Кредиты" not in batch_data:
                                print(f"         [FIX] GPT вернул 'Договоры', переименовываю в 'Кредиты'")
                                batch_data["Кредиты"] = batch_data.pop("Договоры")
                            
                            # Добавляем кредиты из этого батча
                            if "Кредиты" in batch_data and isinstance(batch_data["Кредиты"], list):
                                batch_credits = batch_data["Кредиты"]
                                
                                # Дополняем ИНН из реестра, если GPT не извлек
                                for credit in batch_credits:
                                    if not credit.get("ИНН_кредитора"):
                                        creditor_name = credit.get("Кредитор", "")
                                        if creditor_name:
                                            _, canonical_name = DocumentProcessor.normalize_bank_name(creditor_name)
                                            inn = DocumentProcessor.get_bank_inn(canonical_name)
                                            if inn:
                                                credit["ИНН_кредитора"] = inn
                                
                                all_credits.extend(batch_credits)
                                print(f"OK ({len(batch_credits)} кредитов)")
                                
                                # Логирование извлечённых кредитов
                                if batch_credits:
                                    print(f"         [ИЗВЛЕЧЕНО]:")
                                    for idx, credit in enumerate(batch_credits, 1):
                                        creditor = credit.get("Кредитор", "???")
                                        date = credit.get("Дата_сделки", "???")
                                        initial = credit.get("Сумма_обязательства", "???")
                                        debt = credit.get("Сумма", "???")
                                        inn = credit.get("ИНН_кредитора", "")
                                        inn_text = f" | ИНН: {inn}" if inn else ""
                                        print(f"           {idx}. {creditor} | Дата: {date} | Начальная: {initial} | Долг: {debt}{inn_text}")
                            else:
                                print("OK (0 кредитов)")
                        except json.JSONDecodeError as json_err:
                            print(f"SKIP (JSON parse failed - likely no credits on these pages)")
                            print(f"         [DEBUG] Ответ GPT (первые 300 символов):")
                            print(f"         {response_text[:300]}")
                            # НЕ устанавливаем error - батч просто не нашёл кредиты
                            
                    except Exception as e:
                        print(f"ERROR ({str(e)[:40]})")
                        if not error:
                            error = f"Batch {batch_num}: {str(e)}"
                
                # Объединяем результаты всех батчей
                extracted_data = {"Кредиты": all_credits}
                print(f"      [BATCH] Всего извлечено кредиторов: {len(all_credits)}")
                
            else:
                # Для небольших документов - обычная обработка
                if doc_type == "отчет_окб":
                    simple_prompt = base_prompt + f"""

Найди таблицу "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ" или "АКТИВНЫЕ ДОГОВОРЫ".

Для КАЖДОЙ строки таблицы:
1. Название кредитора (например: МТС-БАНК ПАО)
2. Найди детальный раздел НИЖЕ с этим кредитором и извлеки:
   - "Дата совершения сделки" или "Дата возникновения обязательства"
   - "Сумма и валюта обязательства" (ОБЯЗАТЕЛЬНО! первоначальная сумма кредита)
   - В разделе "Сведения об источнике" ищи строку "ИНН и ОГРН (ОГРНИП)". Там будет текст вида: "ИНН³ 7744000912" и строкой ниже "ОГРН 1027739019142"
   - ИНН - это число из строки с пометкой "ИНН³" (10 цифр). ОБЯЗАТЕЛЬНО извлеки его!
   - ОГРН НЕ НУЖЕН (это 13 цифр)
   - Тип кредита/займа (из колонки "Вид обязательства" или аналогичной: Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, Необеспеченный кредит, и т.д.)
   - В таблице "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ" колонка "Общая задолженность":
     Возьми значение из колонки "Общая задолженность" = текущий долг

КРИТИЧЕСКИ ВАЖНО ПРО ДОЛГ В ОКБ:
- Используй ТОЛЬКО "Общая задолженность" из таблицы "ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ"
- "Общая задолженность" УЖЕ ВКЛЮЧАЕТ просрочку, проценты и всё остальное!
- ИЛИ сложи "Основной долг" + "Проценты" + "Иное" из детального раздела НИЖЕ в таблице "Сведения о сумме задолженности"
- НЕ суммируй "Общая задолженность + Просроченная задолженность" в таблице ДЕЙСТВУЮЩИЕ КРЕДИТНЫЕ ДОГОВОРЫ!
- Просто возьми значение "Общая задолженность" как есть

JSON:
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "ИНН_кредитора": "число из строки 'ИНН³' в разделе 'Сведения об источнике' (10 цифр, например: 7744000912)",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "ДД.ММ.ГГГГ",
      "Сумма_обязательства": "первоначальная сумма",
      "Сумма": "значение из 'Общая задолженность' (НЕ складывать!)"
    }}
  ]
}}"""
                elif doc_type == "отчет_бки":
                    simple_prompt = base_prompt + f"""

Найди таблицу "АКТИВНЫЕ ДОГОВОРЫ".

Для КАЖДОЙ строки таблицы извлеки:
- Кредитор (точное название)
- Дата начала договора (из колонки "Дата начала договора")
- Тип кредита/займа (из колонки "Вид обязательства" или аналогичной: Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, Необеспеченный кредит, и т.д.)
- Сумма обязательства по договору (ОБЯЗАТЕЛЬНО! первоначальная сумма кредита)
- Текущий долг = "Текущая задолженность" + "Текущая просрочка, сумма"

ВАЖНО: 
- "Сумма обязательства по договору" - это НЕ текущий долг!
- Поле в JSON ОБЯЗАТЕЛЬНО должно называться "Кредиты", НЕ "Договоры"!

JSON (СТРОГО этот формат):
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "дата",
      "Сумма_обязательства": "первоначальная сумма",
      "Сумма": "текущий долг"
    }}
  ]
}}"""
                else:  # отчет_нбки
                    simple_prompt = base_prompt + f"""

Найди раздел с заголовком "Обязательства и их исполнение" - там начинается список кредиторов.

Для КАЖДОГО кредитора:
1. Название банка/кредитора (заголовок раздела)
2. В таблице "Основные сведения об обязательстве":
   - Столбец "Сумма и валюта обязательства" = первоначальная сумма займа (Сумма_обязательства)
   - Столбец "Дата возникновения обязательства" = дата сделки (Дата_сделки)
   - Столбец "ОГРН/ИНН" - там два числа через пробел. ПЕРВОЕ (13 цифр) - это ОГРН, НЕ НУЖНО. ВТОРОЕ (10 цифр) - это ИНН кредитора, ОБЯЗАТЕЛЬНО извлеки!
   - Тип кредита/займа (из строки "Вид обязательства": Потребительский кредит, Кредитная карта, Микрозайм, Ипотека, Автокредит, и т.д.)
3. В таблице "Задолженность":
   - Найди САМУЮ ПОСЛЕДНЮЮ строку в таблице
   - Возьми значение из столбца "Сумма" (это текущий долг)
   - ИГНОРИРУЙ другие столбцы

КРИТИЧЕСКИ ВАЖНО:
- Берем ТОЛЬКО последнюю строку таблицы "Задолженность"
- Берем ТОЛЬКО столбец "Сумма"
- НЕ суммируем, просто берем одно значение!
- В столбце "ОГРН/ИНН" берем ВТОРОЕ число (10 цифр) - это ИНН!

JSON (СТРОГО этот формат):
{{
  "Кредиты": [
    {{
      "Кредитор": "название",
      "ИНН_кредитора": "ВТОРОЕ число из столбца ОГРН/ИНН (10 цифр)",
      "Вид": "тип кредита (Потребительский кредит/Кредитная карта/Микрозайм/Ипотека/Автокредит/другое)",
      "Дата_сделки": "ДД.ММ.ГГГГ",
      "Сумма_обязательства": "первоначальная сумма",
      "Сумма": "последняя строка таблицы Задолженность, столбец Сумма"
    }}
  ]
}}"""

                try:
                    print(f"      Обработка ({len(pages)} стр.)...", end=" ", flush=True)
                    response_text, error_code = self.process_images_with_gpt(page_images, simple_prompt)
                    
                    # Если ошибка 400/500 - переключаемся на батч-режим
                    if error_code in [400, 500]:
                        print(f"ERROR {error_code}, переключаюсь на батч-режим...")
                        use_batch = True
                        batch_size = 30  # Начинаем с меньшего размера
                        # Рекурсивно вызываем батч-обработку выше
                        # Но это проще сделать через отдельную функцию. Пока просто обрабатываем ошибку
                        extracted_data = {}
                        error = f"Document too large (error {error_code}), but batch processing not available in this code path"
                    else:
                        cleaned = self.clean_json_response(response_text)
                        try:
                            extracted_data = json.loads(cleaned) if cleaned else {}
                            
                            # FALLBACK: если GPT вернул "Договоры" вместо "Кредиты"
                            if "Договоры" in extracted_data and "Кредиты" not in extracted_data:
                                print(f"      [FIX] GPT вернул 'Договоры', переименовываю в 'Кредиты'")
                                extracted_data["Кредиты"] = extracted_data.pop("Договоры")
                            
                            credits = extracted_data.get("Кредиты", [])
                            credit_count = len(credits)
                            print(f"OK ({credit_count} кредитов)")
                            
                            # Логирование извлечённых кредитов
                            if credits:
                                print(f"      [ИЗВЛЕЧЕНО]:")
                                for idx, credit in enumerate(credits, 1):
                                    creditor = credit.get("Кредитор", "???")
                                    date = credit.get("Дата_сделки", "???")
                                    initial = credit.get("Сумма_обязательства", "???")
                                    debt = credit.get("Сумма", "???")
                                    inn = credit.get("ИНН_кредитора", "")
                                    
                                    # Если ИНН нет - пробуем получить из реестра
                                    if not inn and creditor != "???":
                                        _, canonical_name = DocumentProcessor.normalize_bank_name(creditor)
                                        inn = DocumentProcessor.get_bank_inn(canonical_name)
                                        if inn:
                                            credit["ИНН_кредитора"] = inn
                                            print(f"        {idx}. {creditor} | Дата: {date} | Начальная: {initial} | Долг: {debt} | ИНН: {inn} (из реестра)")
                                        else:
                                            print(f"        {idx}. {creditor} | Дата: {date} | Начальная: {initial} | Долг: {debt}")
                                    else:
                                        print(f"        {idx}. {creditor} | Дата: {date} | Начальная: {initial} | Долг: {debt} | ИНН: {inn}")
                        except json.JSONDecodeError as json_err:
                            print(f"ERROR (JSON parse failed)")
                            print(f"      [DEBUG] Ответ GPT (первые 500 символов):")
                            print(f"      {response_text[:500]}")
                            extracted_data = {}
                            error = f"JSON parse error: {str(json_err)}"
                except Exception as e:
                    print(f"ERROR ({str(e)[:50]})")
                    extracted_data = {}
                    error = str(e)

            
            # Удаляем временные файлы
            for tmp_path in page_images:
                try:
                    os.unlink(tmp_path)
                except:
                    pass

            elapsed = time.time() - start_time

            return DocumentOutput(
                file=pdf_path.name,
                document_type=doc_type,
                pages=len(pages),
                processing_time_seconds=round(elapsed, 2),
                data=extracted_data,
                error=error,
                extracted_text=None,
            )

        # FALLBACK: Если PDF API не сработал, используем старый метод (Vision API)
        # Этот блок больше не используется для кредитных отчётов, но оставляем на случай отладки
        if False and doc_type in ["отчет_окб_OLD", "отчет_бки_OLD", "отчет_нбки_OLD"]:
            print(f"      [CREDIT] Обработка кредитного отчета (Vision API - FALLBACK)")

            # Конвертируем PDF в изображения (ВСЕ страницы - чтобы не потерять долги!)
            print(f"      Конвертация PDF в изображения...", end=" ", flush=True)
            pdf = pdfium.PdfDocument(str(pdf_path))
            total_pages = len(pdf)  # ОБРАБАТЫВАЕМ ВСЕ СТРАНИЦЫ
            pages = []
            for i in range(total_pages):
                page = pdf[i]
                bitmap = page.render(scale=2.5)  # scale 2.5 ≈ 200 DPI
                pil_image = bitmap.to_pil()
                pages.append(pil_image)
            print(f"OK ({len(pages)} стр.)")

            # Сохраняем страницы во временные файлы
            print(f"      Сохранение страниц...", end=" ", flush=True)
            page_images = []
            for i, page in enumerate(pages):
                with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as tmp_file:
                    tmp_path = tmp_file.name
                    page.save(tmp_path, 'JPEG', quality=95, optimize=True)
                    page_images.append(tmp_path)
            print("OK")

            # БАТЧИНГ: Если страниц > 100, разбиваем на порции
            # Увеличен размер батча до 100 стр., чтобы большинство отчётов обрабатывались целиком
            # Это критически важно для МФК/МКК, т.к. их данные могут быть разбросаны по документу
            BATCH_SIZE = 100  # максимум страниц за раз
            all_credits = []
            error = None

            if len(page_images) > BATCH_SIZE:
                print(f"      [BATCH] Документ большой ({len(page_images)} стр.), обработка по {BATCH_SIZE} стр...")
                
                # Разбиваем на батчи
                for batch_start in range(0, len(page_images), BATCH_SIZE):
                    batch_end = min(batch_start + BATCH_SIZE, len(page_images))
                    batch_images = page_images[batch_start:batch_end]
                    batch_num = (batch_start // BATCH_SIZE) + 1
                    total_batches = (len(page_images) + BATCH_SIZE - 1) // BATCH_SIZE
                    
                    # Промпт для батча
                    batch_prompt = base_prompt + f"""

Это ЧАСТЬ {batch_num}/{total_batches} кредитного отчета (стр. {batch_start+1}-{batch_end} из {len(page_images)}).
Извлеки ВСЕ кредиты из этой части!

КРИТИЧЕСКИ ВАЖНО:
1. Поле 'Прекращение обязательств': 'Н/Д' → долг активен, дата → погашен
2. Раздел 'Задолженность' — последняя строка > 0 → есть долг
3. Извлекай: ИНН, дату договора, тип, сумму
4. Один кредитор несколько раз → отдельные записи с разными датами!

ВЕРНИ ТОЛЬКО JSON со списком кредитов!"""
                    
                    try:
                        print(f"      Батч {batch_num}/{total_batches} (стр. {batch_start+1}-{batch_end})...", end=" ", flush=True)
                        response_text, error_code = self.process_images_with_gpt(batch_images, batch_prompt)
                        cleaned = self.clean_json_response(response_text)
                        batch_data = json.loads(cleaned) if cleaned else {}
                        
                        # Извлекаем кредиты из батча
                        batch_credits = batch_data.get("Кредиты") or batch_data.get("Договоры") or []
                        all_credits.extend(batch_credits)
                        print(f"OK (+{len(batch_credits)} кред.)")
                    except Exception as e:
                        print(f"ERROR ({str(e)[:30]})")
                        if not error:  # Сохраняем первую ошибку
                            error = str(e)
                        continue
                
                # Формируем финальный результат
                extracted_data = {
                    "Кредиты": all_credits,
                    "Количество_активных_кредитов": len(all_credits)
                }
            else:
                # Обычная обработка для небольших отчётов (≤25 стр)
                credit_prompt = base_prompt + f"""

Это кредитный отчет ({len(pages)} стр.).
ПРОАНАЛИЗИРУЙ ВСЕ СТРАНИЦЫ!

КРИТИЧЕСКИ ВАЖНО:
1. Поле 'Прекращение обязательств': 'Н/Д' → долг активен, дата → погашен
2. Раздел 'Задолженность' — последняя строка > 0 → есть долг
3. Извлекай: ИНН, дату договора, тип, сумму задолженности
4. Один кредитор несколько раз → отдельные записи!

ВЕРНИ ТОЛЬКО JSON!"""

                try:
                    print(f"      Обработка GPT-4o ({len(pages)} стр.)...", end=" ", flush=True)
                    response_text, error_code = self.process_images_with_gpt(page_images, credit_prompt)
                    cleaned = self.clean_json_response(response_text)
                    extracted_data = json.loads(cleaned) if cleaned else {}
                    print("OK")
                except Exception as e:
                    print(f"ERROR ({str(e)[:50]})")
                    extracted_data = {}
                    error = str(e)
            
            # Удаляем временные файлы
            for tmp_path in page_images:
                try:
                    os.unlink(tmp_path)
                except:
                    pass

            elapsed = time.time() - start_time
            total_pages = len(pages)

            return DocumentOutput(
                file=pdf_path.name,
                document_type=doc_type,
                pages=total_pages,
                processing_time_seconds=round(elapsed, 2),
                data=extracted_data,
                error=error,
                extracted_text=None,
            )

        # === ОБЫЧНАЯ ОБРАБОТКА ДЛЯ ОСТАЛЬНЫХ ДОКУМЕНТОВ ===
        # Convert PDF to images using pypdfium2
        print(f"      Конвертация PDF в изображения...", end=" ", flush=True)
        pdf = pdfium.PdfDocument(str(pdf_path))
        total_pages = len(pdf)
        pages = []
        for i in range(total_pages):
            page = pdf[i]
            bitmap = page.render(scale=2.0)  # scale 2.0 ≈ 150 DPI
            pil_image = bitmap.to_pil()
            pages.append(pil_image)
        print(f"OK ({total_pages} стр.)")
        saved_page_paths: List[str] = []
        extracted_data: Dict[str, Any] = {}
        error: Optional[str] = None

        try:
            # Save all pages as temporary JPEG files
            print(f"      Сохранение страниц...", end=" ", flush=True)
            for page in pages:
                with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as tmp_file:
                    tmp_path = tmp_file.name
                    page.save(tmp_path, "JPEG", quality=95, optimize=True)
                    saved_page_paths.append(tmp_path)
            print(f"OK")

            # Create multi-page prompt
            multi_page_prompt = f"""{base_prompt}

Это документ содержит {len(pages)} страниц(ы). Все страницы представлены ниже.
Проанализируй ВСЕ изображения и извлеки данные согласно инструкции.
Объедини информацию со всех страниц в один JSON объект.
Верни результат СТРОГО в формате JSON."""

            print(f"      Обработка всех страниц GPT-5...", end=" ", flush=True)

            # Process all pages at once with GPT-5 Vision
            response_text, error_code = self.process_images_with_gpt(saved_page_paths, multi_page_prompt)
            cleaned = self.clean_json_response(response_text)

            try:
                extracted_data = json.loads(cleaned)
                if error_code:
                    print(f"WARN - Error {error_code}")
                else:
                    print(f"OK")
            except json.JSONDecodeError as e:
                error = f"JSON decode error: {str(e)}"
                extracted_data = {"raw_response": response_text, "error": error}
                print(f"WARN - JSON error")
        except Exception as exc:
            error = str(exc)
            extracted_data = {"error": str(exc)}
            print(f"ERROR: {str(exc)[:50]}")
        finally:
            # Clean up temporary files
            for tmp_path in saved_page_paths:
                try:
                    os.remove(tmp_path)
                except OSError:
                    continue

        elapsed = time.time() - start_time
        return DocumentOutput(
            file=pdf_path.name,
            document_type=doc_type,
            pages=len(pages),
            processing_time_seconds=round(elapsed, 2),
            data=extracted_data,
            error=error,
            extracted_text=None,
        )

    def process_batch(
        self,
        pdf_paths: Iterable[Path],
        output_json: Optional[Path] = None,
        debtor_id: Optional[str] = None,
        lawyer: Optional[str] = None,
    ) -> tuple[List[DocumentOutput], Dict[str, List[Dict[str, Any]]], List[Path]]:
        results: List[DocumentOutput] = []
        aggregated: Dict[str, List[Dict[str, Any]]] = {}
        pdf_list = list(pdf_paths)  # Конвертируем в список для повторного использования

        # Сортируем файлы: паспорт обрабатываем первым, потом остальные
        def sort_key(path: Path) -> tuple[int, str]:
            filename_lower = path.name.lower()
            if "паспорт" in filename_lower or "passport" in filename_lower:
                return (0, path.name)  # паспорт первым
            elif "егрн" in filename_lower or "выписка" in filename_lower:
                return (2, path.name)  # ЕГРН после паспорта, но перед остальными
            else:
                return (1, path.name)  # остальные документы

        sorted_pdf_list = sorted(pdf_list, key=sort_key)

        for pdf in sorted_pdf_list:
            try:
                result = self.process_pdf(pdf)
            except Exception as exc:  # noqa: BLE001
                result = DocumentOutput(
                    file=pdf.name,
                    document_type="ошибка",
                    pages=0,
                    processing_time_seconds=0.0,
                    data={},
                    error=str(exc),
                )
            results.append(result)
            if not result.error and isinstance(result.data, dict) and "raw_output" not in result.data:
                aggregated.setdefault(result.document_type, []).append(result.data)

        # Передаем список файлов для формирования приложений (используем исходный порядок для приложений)
        template_context = self.prepare_template_context(aggregated, pdf_list, client)
        filled_templates = self.generate_all_documents(template_context, debtor_id=debtor_id, lawyer=lawyer)
        if output_json:
            # Сохраняем template_context для последующего редактирования и регенерации
            # Сначала нормализуем маркеры переноса строки в реальные '\n',
            # затем конвертируем RichText объекты в строки для JSON сериализации
            normalized_context = DocumentProcessor._normalize_line_breaks(template_context)
            serializable_context = self._make_json_serializable(normalized_context)
            with open(output_json, "w", encoding="utf-8") as handle:
                json.dump(serializable_context, handle, ensure_ascii=False, indent=2)
        return results, aggregated, filled_templates

    @staticmethod
    def _make_json_serializable(obj: Any) -> Any:
        """Конвертирует RichText объекты и другие несериализуемые типы в строки."""
        from docxtpl import RichText
        
        if isinstance(obj, RichText):
            # RichText содержит XML-разметку, нужно извлечь чистый текст
            # Получаем строковое представление
            rich_text_str = str(obj)
            
            # Удаляем все XML-теги, извлекая только текстовое содержимое
            # Паттерн ищет содержимое между <w:t>...</w:t> или <w:t xml:space="preserve">...</w:t>
            text_content = re.findall(r'<w:t[^>]*>(.*?)</w:t>', rich_text_str)
            
            if text_content:
                # Объединяем найденные фрагменты текста
                return ''.join(text_content)
            else:
                # Если паттерн не нашел ничего, пробуем просто удалить все XML теги
                clean_text = re.sub(r'<[^>]+>', '', rich_text_str)
                return clean_text.strip() if clean_text.strip() else ""
        elif isinstance(obj, dict):
            return {key: DocumentProcessor._make_json_serializable(value) for key, value in obj.items()}
        elif isinstance(obj, list):
            return [DocumentProcessor._make_json_serializable(item) for item in obj]
        elif isinstance(obj, (str, int, float, bool, type(None))):
            return obj
        else:
            # Для других типов пытаемся привести к строке
            return str(obj)

    @staticmethod
    def _normalize_line_breaks(obj: Any) -> Any:
        """Рекурсивно заменяет маркеры переноса строки на настоящий '\n' в строках перед сериализацией.

        Заменяем шаблонные маркеры вида '{{LINE_BREAK}}', '{{ LINE_BREAK }}', '{LINE_BREAK}'
        и отдельные токены 'LINE_BREAK' (как отдельное слово) на реальный перевод строки.
        """
        import re

        if isinstance(obj, dict):
            return {k: DocumentProcessor._normalize_line_breaks(v) for k, v in obj.items()}
        if isinstance(obj, list):
            return [DocumentProcessor._normalize_line_breaks(v) for v in obj]
        if isinstance(obj, str):
            # replace brace variants
            s = re.sub(r"\{\{\s*LINE_BREAK\s*\}\}|\{LINE_BREAK\}", "\n", obj)
            # replace standalone token LINE_BREAK when it's a separate word
            s = re.sub(r"(?<!\w)LINE_BREAK(?!\w)", "\n", s)
            return s
        return obj


__all__ = ["DocumentProcessor", "DocumentOutput", "GPT_MODEL"]


# === CLI Interface ===
def main():
    """Запуск обработки документов из командной строки."""
    import sys
    from pathlib import Path

    print("=" * 70)
    print("  PROCESSING BANKRUPTCY DOCUMENTS")
    print("=" * 70)
    print()

    # Запрашиваем папку с документами
    if len(sys.argv) > 1:
        input_folder = Path(sys.argv[1])
    else:
        folder_input = input("Введите путь к папке с PDF документами: ").strip().strip('"')
        if not folder_input:
            print("ERROR - Путь не указан!")
            return
        input_folder = Path(folder_input)

    if not input_folder.exists():
        print(f"ERROR - Папка не найдена: {input_folder}")
        return

    if not input_folder.is_dir():
        print(f"ERROR - Это не папка: {input_folder}")
        return

    # Ищем PDF файлы
    pdf_files = list(input_folder.glob("*.pdf"))

    if not pdf_files:
        print(f"ERROR - В папке не найдено PDF файлов: {input_folder}")
        return

    print(f"OK - Найдено {len(pdf_files)} PDF файл(ов):")
    for i, pdf in enumerate(pdf_files, 1):
        print(f"   {i}. {pdf.name}")
    print()

    # Создаем процессор
    processor = DocumentProcessor()

    # Запускаем обработку
    print("Начинаем обработку документов...")
    print()

    output_json = input_folder / "результат_обработки.json"

    overall_start = time.time()

    try:
        results, aggregated, filled_template = processor.process_batch(
            pdf_files,
            output_json=output_json
        )

        overall_elapsed = time.time() - overall_start

        print()
        print("=" * 70)
        print("  PROCESSING COMPLETE")
        print("=" * 70)
        print(f"  Total time: {overall_elapsed:.1f} seconds ({overall_elapsed/60:.1f} min)")
        print()

        # Показываем результаты
        for result in results:
            status = "[+]" if not result.error else "[-]"
            print(f"{status} {result.file}")
            print(f"   Тип: {result.document_type}")
            print(f"   Страниц: {result.pages}")
            print(f"   Время: {result.processing_time_seconds} сек")
            if result.error:
                print(f"   WARNING - Ошибка: {result.error}")
            print()

        # Сохраненные файлы
        print("Created files:")
        print(f"   > {output_json.name} - JSON с извлеченными данными")


        if filled_template:
            for tmpl in filled_template:
                print(f"   > {tmpl.name}")

        print()
        print(f"All files saved to: {input_folder}")
        print()

        # Показываем статистику
        total_docs = len(results)
        successful = sum(1 for r in results if not r.error)
        failed = total_docs - successful

        print("Statistics:")
        print(f"   Всего документов: {total_docs}")
        print(f"   Обработано успешно: {successful}")
        if failed > 0:
            print(f"   С ошибками: {failed}")

        print()
        print("Done! Check the filled template.")

    except KeyboardInterrupt:
        print()
        print("WARNING - Processing interrupted by user")
    except Exception as exc:
        print()
        print(f"ERROR - {exc}")
        try:
            import traceback
            traceback.print_exc()
        except Exception as te:
            print(f"[TRACEBACK ERROR] Failed to print traceback: {te}")


if __name__ == "__main__":
    main()

